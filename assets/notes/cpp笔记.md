# c/cpp笔记

* cpp多态如何实现
  * 概念：在面向对象过程中，多态是向不同对象发送相同消息做出不同行为（方法）。在 cpp 中就是相同的函数签名可以有不同的实现
  * 多态分为静态多态和动态多态，静态多态包括函数重载、泛型编程，动态多态包括虚函数
  * 动态多态：虚函数的实现
    * 根据虚函数机制在运行时根据调用对象来判断具体调用哪一个函数，是一种动态绑定的机制，因此增加时间开销；因为需要虚表和虚指针，增加内存开销
    * 条件：
      1. 必须是虚函数（一定在派生类中对基类虚函数进行重写）
      2. 通过基类类型引用或指针指向子类对象（通过基类类型指针或引用调用虚函数时，要根据运行时指针实际指向的类型确认基类还是派生类的虚函数；调用非虚函数时，都调用基类的函数）
    * 编译器为每个包含虚函数的类生成一张虚函数表，即存放每个虚函数地址的函数指针数组，简称虚表(vtbl)，每个虚函数对应虚函数表中的一个索引号
    * 编译器还会为该类增加一个隐式的成员变量，通常在该类实例化对象的起始位置，用于存放虚函数表的首地址，该变量被称为虚函数表指针，简称虚指针(vptr)
    * 虚函数表是一个类一张，所有对象通过虚指针共享同一张虚表
    * 虚函数覆盖本质是用子类的虚函数地址覆盖拷贝的基类表中对应的基类虚函数地址
    * [参考链接](https://blog.csdn.net/u010126059/article/details/50768646)
  * [参考链接](https://blog.csdn.net/apt1203jn/article/details/78506855)

* 什么是封装，面向对象和面向过程有什么区别
  * 封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口
  * 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为
  * 面向过程是编年体；面向对象是纪传体

* cpp文件是怎么运行起来的
  * cpp语言要想运行起来，就要通过翻译环境把 .cpp 文件翻译成机器可以识别的机器码
  * cpp 翻译过程可以分为编译和链接两个阶段
  * 编译分为预编译、编译、汇编
    * 预编译是文件操作，将头文件包含，删除注释，宏定义替换，.c 文件经过预编译成为 .i 文件
    * 编译是将源代码翻译成汇编代码，包括词法分析、语法分析、语义分析、源代码优化、代码生成和目标代码优化。.i 编译成 .s 文件
    * 汇编是将汇编代码翻译成机器代码，.s 汇编成 .o 文件
  * 链接是符号表的合并和重定义
    * 生成 .exe 文件

* cpp文件运行时的堆和栈
  * 栈区是分配局部变量的空间，栈的空间是自动分配自动回收的，生存周期只在函数的运行过程；由系统分配，速度较快；栈地址向小地址增长
  * 堆由 new 分配，需要手动回收空间，否则造成内存泄漏，分配速度较慢

* 设计一个类，只能生成该类的一个实例（单例模式）
  * 饿汉模式：直接在静态区初始化 instance，然后通过 getInstance() 返回
    * 称为懒汉是因为，不论这个单例会不会被使用都会被初始化，空间换时间，在之后的使用过程中不用再生成单例
  * 懒汉模式：在 getInstance() 里构造单例并且返回
    * 称为懒汉是因为只有在需要用到单例的时候才返回单例，时间换空间，每次取单例的时候都需要判断生成返回
    * 构造函数和析构函数都是私有成员，不会被外界调用，类有一个指向自己的静态指针
    * 通过静态函数 getInstance() new 出一个对象赋值给静态指针，返回
    * getInstance() 方法需要处理多线程环境，需要对生成对象代码加锁
    ```c
    Singleton* getInstance()
    {
        if (instance == NULL)
        {
          lock();
          if (instance == NULL)
          {
              instance = new Singleton();
          }
          unlock();
        }
        return instance;
    }
    ```

* auto 和 static
  * auto 是由程序自动控制变量的生存周期，变量在进入作用域的时候被分配，离开作用域的时候被释放； static 在程序初始化时被分配，直到程序退出前才被释放
  * static 声明变量或者函数，实现不需要 static修饰

* cpp static 和 java static 的异同

* 智能指针

* struct和class的区别

* 结构体struct和联合体union的区别

## 虚函数

* **虚函数的具体实现原理**
* c++虚函数
  * 虚函数是一种在基类定义为virtual的函数，并在一个或多个派生类中再定义的函数。虚函数的特点是，只要定义一个基类的指针，就可以指向派生类的对象。
  * 注：无虚函数时，遵循以下规则：C++规定，定义为基类的指针，也能作指向派生类的指针使用，并可以用这个指向派生类对象的指针访问继承来的基类成员；但不能用它访问派生类的成员
  * 使用虚函数实现运行时的多态性的关键在于：必须通过基类指针访问这些函数
  * 含有纯虚函数的基类称为抽象基类。抽象基类又一个重要特性：抽象类不能建立对象。但是抽象基类可以有指向自己的指针，以支持运行时的多态性。
  * 它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。
  * 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类

* 虚函数覆盖的条件
  * 只有类的成员函数才能被声明为虚函数，全局函数和类的静态成员函数都不能被声明为虚函数。
  * 只有在基类中被冠以virtual关键字的成员函数才能作为虚函数被子类覆盖，而与子类中virtual关键字无关。

* c++ 析构函数为何需要使用Visual修饰
  * C++中基类采用virtual虚析构函数是为了防止内存泄漏
  * 如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏

## STL

* map数据结构，时间复杂度

## 内存

* **c++内存管理模型**
* stl内存分配
* c++内存
  * c++内存分为栈、堆、程序代码区、静态区、文字常量区
  * 栈存放临时变量、函数
  * 堆存放new的对象
  * 虚函数表在静态区

* 参考书籍《深度探索c++对象模型》