# 操作系统

* 操作系统的基本特性
  * 并发、共享、虚拟、异步
  * 并发是多个事件在同一时间间隔内发生，并行是同一时刻同时进行计算，需要有硬件支持，比如多核
  * 并发和共享是多用户OS的两个最基本的特性
  * [参考链接](https://blog.csdn.net/gh6267/article/details/77891736)

* 进程、线程、携程
  * 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
  * 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度。
  * 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。

* 堆、栈
  * 栈是由编译器在需要时分配，不需要时自动清除的变量存储区，里面的变量通常是局部变量，函数参数，上下文等。它保存了一个函数调用所需要维护的信息，称为活动记录
  * 堆是用于动态分配内存，new/free

* 线程进程区别
  * 进程是资源调度的基本单位，操作系统为不同的进程分配资源
  * 线程是独立调度的基本单位，共享同一进程的资源

* 死锁产生条件和解决
  * 死锁产生：线程/进程间相互等待资源又不释放自身的资源，导致了无穷的等待
  * 产生的四个必要条件：
    1. 互斥：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用
    2. 请求和保持：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有
    3. 不被剥夺：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放
    4. 环路等待：
  * 解决方法：
    1. 死锁预防：破坏四个必要条件中的一个或多个
    2. 死锁避免：系统对资源申请进行动态检查，根据检查结果决定分配资源与否，如果分配资源后可能导致死锁则不分配
    3. 死锁检测和解除

* 同步io和异步io的区别，io复用技术
* epoll优于select的原因
* 线程池
* 事件驱动（select、poll、epoll）

* 谈一下对乐观锁和悲观锁的认识

## Linux

* linux系统用什么指令看内存
  * top, free

* cache和buffer的区别
  * cache（缓存）的英文解释：A cache is something that has been "read" from the disk and stored for later use.  就是说，cache是从硬盘或者存储设备读进计算机后缓存在内存中的数据。cache 为了提高cpu和内存之间的数据交换速度而设计的。 cpu在执行程序所用的指令和读数据都是针对内存的，也就是从内存中取得的。由于内存读写速度慢，为了提高cpu和内存之间数据交换的速度，在cpu和内存之间增加了cache
  * buffers（缓冲），其英文解释是：A buffer is something that has yet to be "written" to disk. 就是说，buffers是将要写入硬盘中的数据缓存。将数据暂时存储在内存，再一次IO写入磁盘，减少IO慢带来的性能损耗
  * Cache和Buffer的相同点：都是2个层面之间的中间层，都是内存。 Cache和Buffer的不同点：**Cache解决的是时间问题，Buffer解决的是空间问题。**为了提高速度，引入了Cache这个中间层。 为了给信息找到一个暂存空间，引入了Buffer这个中间层。

* cache 的数据结构和实现

* linux进程通信方式有什么
  * 共享内存，需要程序员自己控制同步，临界区处理
  * socket
  * 信号量
  * 管道
    * 管道是内核的一段缓冲区
    * 普通管道pipe，单向传输，例如父进程对子进程，父进程创建管道，得到两个文件描述符指向管道的两端；父进程fork出子进程，子进程也有两个文件描述符指向同一个管道
    * 流管道s_pipe，半双工
    * 命名管道name_pipe，可以在不相关的进程间通信
  * 消息队列
* linux一个文件中，每一行都是一个数据，有重复数据，用shell如何去重
  * sort进行排序，uniq去除重复行。uniq不会检查重复的行，除非是相邻的行
  * awk去除重复行，思路是以每一行的$0为key，创建一个hash数组，后续碰到的行，如果数组里已经有了，就不再print了，否则将其print

* 参考书籍：《Unix 高级环境编程》