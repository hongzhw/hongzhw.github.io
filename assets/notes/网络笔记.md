# 网络

* 既要有ip又要有mac地址的原因
  * ip地址工作在网络层，mac地址工作在链路层，网络层并不一定要有ip地址，例如ipx协议，链路层也不一定要有mac地址
  * mac地址就像身份证一样，和辨别人有关，和所在位置无关。ip地址表示的是当前机器在网络中的位置，类似城市+道路号+门牌号。到了一个门牌后，通过身份证分人
  * 历史原因，mac地址出现在ip地址之前，最初没有路由器只有集线器
  * 设计原因：实现网络层和链路层的分层
  * 信息传递时通过mac地址获取下一跳地址，每一跳都会发生改变，ip地址为终点地址不会改变

* TCP三次握手：为什么要三次握手，不能两次或者四次
  * 两次握手不能保证双方连接正确建立，四次握手没有必要
  * 两次握手出现的问题：客户端发送连接请求，在超时后才接收到ack，客户端会丢弃这个ack，而服务端会保持连接浪费资源
  * 三次握手过程：客户端发送连接请求，syn（syn=j）包，进入 SYN_SENT 状态；服务端收到客户端的syn包后，发送一个ack（ack=j+1）包和自己的syn（syn=k）包，进入 SYN_RECV 状态；客户端收到服务端的ack包和syn包后，发送一个ack（ack=k+1）包给服务端，正确连接客户端和服务端进入 ESTABLISHED 状态

* TCP四次挥手：为什么需要四次，TCP挥手的状态过程
  * TCP连接是两条通道，分别是客户端向服务端的通道和服务端向客户端的通道
  * 客户端发送 fin 包给服务器进入 FIN_WAIT_1 状态；服务器返回ack包进入 CLOSE_WAIT 状态，客户端向服务端通道关闭，客户端进入等待服务器连接关闭状态 FIN_WAIT_2 ；服务器数据发送完后，发送fin包给客户端进入 LAST_ACK 状态，客户端返回ack包进入 TIME_WAIT 状态（等待 2MSL 时间再断开连接），服务器确认 ack 无误后进入 CLOSED 状态，客户端、服务器关闭连接
  * 客户端最后等待 2MSL 时间的原因是，如果客户端返回给服务器的 ack 包服务器没有收到，服务器会再次发送 fin 包

* UDP和TCP的区别
  * UDP将重传、乱序处理交由应用层程序来做，加快了传输速度
  * TCP更注重可靠性而不是实时性
  * UDP注重实时性，对可靠性要求不高：在线视频通话
  * TCP是数据可靠传输，可靠是因为做了重传、有序处理

* TCP 保证可靠性的方式
  * 校验和
  * 序列号（保证有序）
  * 确认应答，ack
  * 超时重传
  * 连接管理
  * 流量控制，滑动窗口
  * 拥塞控制

* 交换机
  * 交换机有自学习能力，学习的是交换表的内容，交换表是mac地址到端口的映射关系

* websocket
  * 出现的原因：http只能通信由客户端发起，是一种单向请求，只能使用轮询来获取服务器的状态变化
  * webdsocket最大的特点是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种
  * 参考链接：[阮一峰websocket教程](http://www.ruanyifeng.com/blog/2017/05/websocket.html)

* get和post的区别
  * get 和 post 是 http 协议的两种发送请求的方法，http 是基于 TCP/IP 的关于数据如何在万维网中通信的协议
  * get 和 post 都是 tcp连接，get 产生一个 tcp 数据包，post 产生两个 tcp 数据包
  * get 是幂等、安全、可缓存的，post 是不幂等、不安全、不可缓存的
  * get 参数写在 url 里，因此有长度限制，url 的长度限制不是 http 协议的限制而是浏览器的限制；post 参数放在 request body 里，对长度没有限制
  * restful 规范中，get 语义是获取资源，post 语义是修改资源

* TCP 拥塞控制
  * 发送方维护拥塞窗口 cwnd 状态变量和慢开始门限 ssthresh 状态变量
  * 慢开始阶段乘性增长->拥塞避免阶段加法增长->网络拥塞 ssthresh 乘性减少
  * 快重传：接收方在收到一个无序的报文段就立即发出重复确认，发送方收到三个重复确认就应当立即重传对方尚未收到的报文段，而不是继续等待设置的计时器到期
  * 快恢复：当发送方收到三个重复确认后，执行乘性减少算法，将ssthresh门限减半，将 cwnd 值设置为新的 ssthresh 值执行拥塞避免算法（加法增长）

* cookie是什么，session是什么，二者的区别和联系
  * cookie 是浏览器保存在用户浏览器上的小文本文件，是客户端保存连接状态的机制
  * session 是服务器保存连接状态的机制
  * cookie 和 session 都是为了解决 http 协议无状态的问题，因为 http 无状态，所以为了分辨链接是谁发起的需要保存状态， cookie 和 session 是保存状态的两种机制
  * cookie 服务器在本地机器上存储的小段文本并随每一个请求发送至同一服务器，是在客户端保持状态的方案。因为 cookie 在客户端，内容可以修改伪造，不安全；且 cookie 不支持跨域，具有不可跨域名性，为了解决同一高级域名下不同子域名可以跨域，设置domain参数
  * session 是在服务端保持状态的方案，会消耗服务器资源和增加服务端的压力。浏览器第一次发送请求时，服务器自动生成了一HashTable和一Session ID来唯一标识这个HashTable，并将 session id 通过响应发送到浏览器保存到浏览器中，每次请求带上 session id

* nginx功能是什么？多进程还是多线程？
  * http 反向代理服务器
  * 多进程，redis 也同样是多进程
  * 事件驱动和多进程线程的比较 [参考链接](https://blog.csdn.net/xxb2008/article/details/42238557)

* http长连接和短连接是什么，各有什么优缺点，使用场景
  * http/1.0 默认短连接，客户端和服务端每进行一次 HTTP 操作就建立一次连接。http/1.1 默认使用长连接，在响应头部会加入Connection:keep-alive
  * 短连接优点：管理比较简单，存在的连接都是有效的连接，不需要额外的控制。缺点：每次连接都需要建立 TCP 连接，浪费时间，用于不需要频繁操作的场景
  * 长连接缺点：客户端连接越来越多，服务器会保持过多的连接，需要对连接做管理。优点：减少建立、断开连接的操作，减少浪费，节省时间，用于频繁操作，点对点的通讯，而且连接数不能太多的场景

* XML和json有什么区别，json传输优势在哪里，为什么会有这样的优势
  * 答：JSON是轻量级的，没有什么冗余信息，使得传输更快，而且解析也容易映射为编程语言，而xml冗余多，解析复杂，导致代码量增多，但xml解析方法DOM和SAX中，SAX可以支持不用将整个文档读入内存，在大文件解析上比Json有优势

* http和https的区别，https如何实现数据加密
  * https是以完全为目的的http通道，简单讲就是安全版的http，即http加入ssl/tls层
  * ssl/tls是工作在传输层的协议，目的是防止数据被窃听和篡改
  * https用的是443端口，http用的是80端口
  * ssl/tls协议为了达到以下目标
    1. 所有信息都是加密传输，第三方无法窃听
    2. 具有校验机制，一旦被篡改，通信双方会立刻发现
    3. 配备身份证书，防止身份被冒充

* tcp 编程和 udp 编程，客户端服务端分别要做的内容
  * [tcp 编程参考链接1](https://blog.csdn.net/zzzzzeenngg/article/details/78509650)
  * [tcp 编程参考链接2](https://www.cnblogs.com/hysum/p/7531529.html)
  * tcp 编程：
    * 服务端：
      1. 创建 socket
      2. bind (命名IP地址和端口号)
      3. listen (创建监听队列)
      4. accept (拿到已经完成连接的 socket)
      5. recv/send (收发数据)
      6. close (关闭)
    * 客户端
      1. 创建 socket
      2. connect (连接目的 socket(ip + port) )
      3. recv/send
      4. close
  * [udp 编程参考链接](https://www.cnblogs.com/skyfsm/p/6287787.html)