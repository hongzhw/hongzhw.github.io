# 面试笔试经历

## 2018.3.27 网易游戏移动端开发 安卓平台 一面

* TCP三次握手：为什么要三次握手，不能两次或者四次

* TCP四次挥手：为什么需要四次

* UDP和TCP的区别
  * UDP将重传、乱序处理交由应用层程序来做，加快了传输速度

* Service运行在什么线程上
  * 答：服务并不是运行在一个独立的进程当中，而是依赖于创建服务时所在的应用程序进程，当某个应用程序进程被啥杀掉的时候，所有依赖该进程的服务都会停止运行。服务不会自动开启线程，所有代码默认在主线程中运行，也就是说我们需要在服务中手动创建子线程执行具体任务
  * 不开新线程时service本身是运行在主线程中

* UI绘制过程：measure、layout、draw分别是如何实现的（看源码）

* 了解fragment以及在不同分辨率下的处理（string、value、dimens）
  * dimens可以根据不同的分辨率设置不同的尺寸
  * fragment
    * 碎片：一个继承Fragment的自定义类，有自己的xml布局文件，在onCreateView()方法里面调用LayoutInflater.inflate()方法获得布局View
    * 动态加载：
      1. 创建待添加的碎片实例
      2. 获取FragmentManager，在活动中直接通过调用getSupportFragmentManager()方法得到
      3. 开启事务FragmentTransaction，通过调用beginTransaction()开启
      4. 向容器（父布局）内添加或者替换碎片，一般使用replace()方法，需要传入容器的id和待添加碎片的实例
      5. 提交事务，调用commit()方法完成
    * 模拟栈
      1. 在事务提交之前，调用FragmentTransaction的addToBackStack()方法
    * 碎片与活动之间进行通信
      1. 活动中调用FragmentManager的findFragmentById()，可以在活动中获得碎片实例，然后就能调用碎片的方法了
      2. 碎片中调用getActivity()来获得与当前碎片相关联的活动
         * 碎片被多个Activity调用
      3. 碎片与碎片之间的通信：在碎片中先获得相关联的活动，然后通过活动获得另外一个碎片的实例
    * 碎片的生命周期
      1. 运行、暂停、停止、销毁四个状态

* 不同UI进行搭配

* XML和json有什么区别，json传输优势在哪里，为什么会有这样的优势

  * 答：JSON是轻量级的，没有什么冗余信息，使得传输更快，而且解析也容易映射为编程语言，而xml冗余多，解析复杂，导致代码量增多，但xml解析方法DOM和SAX中，SAX可以支持不用将整个文档读入内存，在大文件解析上比Json有优势

* 什么是封装，面向对象和面向过程有什么区别
  * 封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口
  * 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为
  * 面向过程是编年体；面向对象是纪传体

* Broadcast的onReceice要注意什么
  * 答：onReceive必须在10秒内执行完毕退出，否则会导致FC(Force Close)，自己做实验测试的时候，写一个死循环，会导致程序无响应。
  * activity和用户交互界面执行时间不能超过5s，BroadcastReceiver执行时间不能超过10s，前台服务不能超过20s，后台服务不能超过200s，否则会导致ANR(Application Not Response)

---

## 2018.3.29 网易游戏 移动端开发（安卓） 复试

* 你的项目有什么地方能体现你的技术的地方

* 你觉得为什么选你不选其他人

* onSaveInstance
  * onSaveInstanceState(Bundle savedInstanceState)在onStop()之前执行
  * onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity(没有调用finish或点击BACK键)，则 onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据，只有系统自动回收的时候才会保存Bundle对象数据（HOME键，电源键，横竖屏切换，启动其他Activity）
  * 为什么按Home键盘会掉用onSaveInstance方法保存数据，按Back不掉用onSaveInstance方法保存数据，因为按下Home键盘没有调用finish函数，如果按下返回键，会调用finish方法

* http和https的区别，https如何实现数据加密
  * https是以完全为目的的http通道，简单讲就是安全版的http，即http加入ssl/tls层
  * ssl/tls是工作在传输层的协议，目的是防止数据被窃听和篡改
  * https用的是443端口，http用的是80端口
  * ssl/tls协议为了达到以下目标
    1. 所有信息都是加密传输，第三方无法窃听
    2. 具有校验机制，一旦被篡改，通信双方会立刻发现
    3. 配备身份证书，防止身份被冒充
  * ssl/tls基本思路：公钥加密法（非对称加密，rsa）

* JNI了解一下

* 网络编程了解一下（http、socket）

* 安卓6.0新特性
  * API level 23
  * 权限管理
    * 运行时权限，运行时检查和请求权限，确定应用是否被授权，调用新增的checkSelfPermission()方法检查权限，调用新增的requestPermission()方法请求权限
  * 低电耗模式和应用待机模式
    * 低电耗模式：如果用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。在该模式下，设备会定期短时间恢复正常工作，以便进行应用同步，还可让系统执行任何挂起的操作。
    * 应用待机模式：应用待机模式允许系统判定应用在用户未主动使用它时处于空闲状态。当用户有一段时间未触摸应用时，系统便会作出此判定。如果拔下了设备电源插头，系统会为其视为空闲的应用停用网络访问以及暂停同步和作业
  * 取消支持Apache Http客户端，改用HttpURLConnection类，效率更高
  * 增加大量过渡动画
  * HttpClient功能移除

* 建议以项目驱动进行学习

---

## 2018.3.27 金山WPS 安卓开发 笔试

* java的Thread类，start()和run()方法有什么区别
  * start启用线程
  * run调用类方法

* Application、Activity、Service都可以作为Context对象使用，各自有什么区别？使用时有什么需要注意的？
  * Application、Service继承ContextWrapper，Activity继承ContextThemeWrapper(ContextThemeWrapper继承ContextWrapper)。Context的实现都在ContextImpl中
  * AlertDialog应该属于一个Activity，所以建立AlertDialog传入的context应该是Activity

* 安卓系统只允许在主线程操作界面视图控件，请简述你对这个限制的理解。如果需要在子线程更新界面，需要怎么做
  * 在checkThread()接口中检查如果当前调用这个接口的线程和ViewRoot中维护的线程不同就会报错"Only the original thread that created a view hierarchy can touch its views."
  * 凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以
  * show a dialog在Application和Service不被允许；start an activity 和 Layout Inflation在Application和Service中不推荐
  * 非Activity的context没有所谓的任务栈，需要为没有任务栈的Activity指定FLAG_ACTIVITY_NEW_TASK标记为，这样启动的时候就会为它创建一个新的任务栈，而此时的Activity是以singleTask的模式启动的
  * getApplication()和getApplicationContext()区别：
    1. 两者的内存地址都是相同的，它们是同一个对象
    2. getApplication()方法的语义性非常强，一看就知道是用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法了
  * 正确使用Context
    1. 一般Context造成的内存泄漏，几乎都是当Context销毁的时候，却因为被引用导致销毁失败
    2. 不要让生命周期长于Activity的对象持有到Activity的引用
    3. 尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有

* 对任意Activity的视图控件树（View Tree）以深度优先遍历的顺序输出 public void dumpViewTree(Activity activity)

---

## 2018.4.3 金山WPS 安卓开发 一面二面

* listview
  * RecycleView相对ListView的优点
    1. 支持多种布局（线性，网格，瀑布，横向）
    2. 动画特效
    3. 局部刷新
    4. 可以支持对列表元素内控件进行事件处理
  * 优化ListView
    0. listivew每次滚动都会调用gitview()方法，所以优化gitview是重中之重
    1. 复用view(convertView)
    2. 使用viewHolder
    3. 不能在getView中执行大量的耗时操作，要开线程
    4. 滑动的时候不要加载图片，在监听器里监听ListView的状态，如果滑动停止加载图片，如果没有滑动加载图片
       * setOnScrollListener
    5. 减少item的布局的深度，因为滑动ListView时会进行测量布局和绘制，将不必要的布局嵌套关系去掉减少绘制时间
  * 控件就是为了交互和展示数据用的，只不过ListView更加特殊，它是为了展示很多很多数据用的，但是ListView只承担交互和展示工作而已，至于这些数据来自哪里，ListView是不关心的。因此，我们能设想到的最基本的ListView工作模式就是要有一个ListView控件和一个数据源
  * Adapter是适配器的意思，它在ListView和数据源之间起到了一个桥梁的作用，ListView并不会直接和数据源打交道，而是会借助Adapter这个桥梁来去访问真正的数据源
  * RecycleBin机制——ListView不会OOM的一个重要原因
    * scrapView存放废弃的view，当元素完全移出屏幕后，元素加入recycleBin，当新的元素进入屏幕时也从recycleBin中获取view

* 线程通信
  * 异步消息机制
  * AsyncTask

* 安卓版本的特性，安卓7，安卓8
  * 安卓7
    * API level:24
    * 多窗口支持：分屏
    * 通知增强功能
    * 后台优化
    * 低电耗模式加强：在 Android N 中，低电耗模式又前进了一步，随时随地可以省电。只要屏幕关闭了一段时间，且设备未插入电源，低电耗模式就会对应用使用熟悉的 CPU 和网络限制。这意味着用户即使将设备放入口袋里也可以省电
    * 快速的应用安装路径：Android 运行组件的 JIT 编译器最实际的好处之一是应用安装和系统更新的速度。即使在Android 6.0 中需要几分钟进行优化和安装的大型应用，现在只需几秒钟就可以完成安装。系统更新也变得更快，因为省去了优化步骤。
    * 号码屏蔽
    * 来电过滤
  * 安卓8
    * API level:24
    * 通知渠道 — Notification Channels：通知渠道是由应用自行定义的通知内容类别，借助渠道，开发者可以让用户对不同种类的通知进行精细控制，用户可以单独拦截或更改每个渠道的行为，而不是统一管理应用的所有通知。
    * 画中画模式 — PIP：Android O 现已支持 Activity 的画中画模式。PIP 是一种多窗口显示模式，多用于视频播放，即你可以一边发微信一边看视频。
    * 自适应图标 — Adaptive Icons：Android 的屏幕适配一直以来都折磨着不少的开发者。为了帮助开发者更好的与设备 UI 集成，Android O 支持创建自适应图标，系统可以基于设备选择的蒙版将这些图标显示为不同形状。系统还将实现与图标的自动交互，并在启动器、快捷方式、设置、共享对话框以及概览屏幕中使用它们。
    * 固定快捷方式和小部件 — Pinning shortcuts：Pinning shortcuts 是一个比 APP shortcuts 更小的快捷方式，放置于桌面上，用于更快速的打开某一 APP 的某单一任务。Pinning shortcuts 在桌面上可呈现不同的图标显示

* get和post区别
  * 语义
    * GET的语义就是「获取资源」，POST的语义是「处理资源」
    * GET的语义是请求获取指定的资源。GET方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader的约束）,GET方法的报文主体没有任何语义
    * POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST不安全，不幂等，（大部分实现）不可缓存
      * Safe - 安全：这里的「安全」和通常理解的「安全」意义不同，如果一个方法的语义在本质上是「只读」的，那么这个方法就是安全的。客户端向服务端的资源发起的请求如果使用了是安全的方法，就不应该引起服务端任何的状态变化，因此也是无害的
      * Idempotent - 幂等：幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同，引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新时遇到POST会给用户提示的原因：POST语义不是幂等的，重复请求可能会带来意想不到的后果。
      * Cacheable - 可缓存性：一个方法是否可以被缓存
    * 例子：在微博这个场景里，GET的语义会被用在「看看我的Timeline上最新的20条微博」这样的场景，而POST的语义会被用在「发微博、评论、点赞」这样的场景中
  * get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制），而post无限制

---

## 2018.4.4 TCL java开发 一面

* 线程sleep和wait区别
  * sleep是Thread类的方法,wait是Object类中定义的方法
  * Thread.sleep不会导致锁行为的改变
  * wait会释放对象锁，必须在synchronized block中执行否则会在programme runtime时扔出"java.lang.IllegalMonitorStateException"异常
  * Thread.sleep和Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。OS会将执行时间分配给其它线程。区别是，调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间
  * sleep 让线程从 [running] -> [阻塞态] 时间结束/interrupt -> [runnable]
  * wait 让线程从 [running] -> [等待队列]notify  -> [锁池] -> [runnable]
  * sleep是一个线程的运行状态控制,wait一个是线程之间的通讯的问题
  * yield让当前运行进程回到可运行状态，也不会释放对象锁

---

## 2018.4.11 腾讯 移动端开发 一面

* TCP和UDP区别
  * TCP更注重可靠性而不是实时性
  * UDP注重实时性，对可靠性要求不高：在线视频通话
  * TCP是数据可靠传输

* 线程进程区别
  * 进程是资源调度的基本单位，操作系统为不同的进程分配资源
  * 线程是独立调度的基本单位，共享同一进程的资源

* 死锁产生条件和解决
  * 死锁产生：线程/进程间相互等待资源又不释放自身的资源，导致了无穷的等待
  * 产生的四个必要条件：
    1. 互斥：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用
    2. 请求和保持：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有
    3. 不被剥夺：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放
    4. 环路等待：
  * 解决方法：
    1. 死锁预防：破坏四个必要条件中的一个或多个
    2. 死锁避免：系统对资源申请进行动态检查，根据检查结果决定分配资源与否，如果分配资源后可能导致死锁则不分配
    3. 死锁检测和解除

* 应用层协议有什么
  * http(80)、https(443)、ftp(20 21)、DNS(53 TCP/UDP)、SMTP(25 TCP)、Telnet(23 TCP)

* 一本书1-N页，有1095个数，求N

* 一亿个数，找出出现次数最多的数
  * 用哈希表（散列表），每个位置都是一个key-value，key为数据value为出现的次数
  * 做一个key-value标识，每次对新数据做哈希的时候，比较标识和新数据的次数大小，决定是否更新标识

---

## 他人面经

* 位图法

---

## 其他知识点

* c++内存
  * c++内存分为栈、堆、程序代码区、静态区、文字常量区
  * 栈存放临时变量、函数
  * 堆存放new的对象
  * 虚函数表在静态区

* c++虚函数
  * 虚函数是一种在基类定义为virtual的函数，并在一个或多个派生类中再定义的函数。虚函数的特点是，只要定义一个基类的指针，就可以指向派生类的对象。
  * 注：无虚函数时，遵循以下规则：C++规定，定义为基类的指针，也能作指向派生类的指针使用，并可以用这个指向派生类对象的指针访问继承来的基类成员；但不能用它访问派生类的成员
  * 使用虚函数实现运行时的多态性的关键在于：必须通过基类指针访问这些函数
  * 含有纯虚函数的基类称为抽象基类。抽象基类又一个重要特性：抽象类不能建立对象。但是抽象基类可以有指向自己的指针，以支持运行时的多态性。
  * 它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。
  * 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类

* c++ 析构函数为何需要使用Visual修饰
  * C++中基类采用virtual虚析构函数是为了防止内存泄漏
  * 如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏

* 如何优化ListView？如何解决ListView复用
* convertView复用的原理是什么

---

## 2018.8.11 华为 通知岗位为安卓开发 实际面试为服务端

### 业务面试

* 哈希，哈希冲突解决方法
  * 回答时拉链法和线性探测法
  * 让开放思维，回答再哈希一次
  * 哈希：散列函数，把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。
  * 哈希冲突解决方法：
    * 开发定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）
    * 链地址法（拉链法，java中HashMap的冲突处理方式）
    * 再哈希法
    * 建立一个公共溢出区

* b树

### 综合面试

* 期待的薪酬
* 在学校做过什么开发
* 有什么想问的吗

---

## 2018.8.20 美团点评 服务端开发

* 学校扫码点餐系统你的模块是怎么做的

* http和https的区别

* mysql的事务隔离级别

* 你觉得有什么优点没有问到的要补充

---

## 2018.8.21 网易互娱 服务端开发

* linux系统用什么指令看内存
  * top, free
* cache和buffer的区别
  * cache（缓存）的英文解释：A cache is something that has been "read" from the disk and stored for later use.  就是说，cache是从硬盘或者存储设备读进计算机后缓存在内存中的数据。cache 为了提高cpu和内存之间的数据交换速度而设计的。 cpu在执行程序所用的指令和读数据都是针对内存的，也就是从内存中取得的。由于内存读写速度慢，为了提高cpu和内存之间数据交换的速度，在cpu和内存之间增加了cache
  * buffers（缓冲），其英文解释是：A buffer is something that has yet to be "written" to disk. 就是说，buffers是将要写入硬盘中的数据缓存。将数据暂时存储在内存，再一次IO写入磁盘，减少IO慢带来的性能损耗
  * Cache和Buffer的相同点：都是2个层面之间的中间层，都是内存。 Cache和Buffer的不同点：**Cache解决的是时间问题，Buffer解决的是空间问题。**为了提高速度，引入了Cache这个中间层。 为了给信息找到一个暂存空间，引入了Buffer这个中间层。
* linux进程通信方式有什么
  * 共享内存，需要程序员自己控制同步，临界区处理
  * socket
  * 信号量
  * 管道
    * 管道是内核的一段缓冲区
    * 普通管道pipe，单向传输，例如父进程对子进程，父进程创建管道，得到两个文件描述符指向管道的两端；父进程fork出子进程，子进程也有两个文件描述符指向同一个管道
    * 流管道s_pipe，半双工
    * 命名管道name_pipe，可以在不相关的进程间通信
  * 消息队列
* linux一个文件中，每一行都是一个数据，有重复数据，用shell如何去重
  * sort进行排序，uniq去除重复行。uniq不会检查重复的行，除非是相邻的行
  * awk去除重复行，思路是以每一行的$0为key，创建一个hash数组，后续碰到的行，如果数组里已经有了，就不再print了，否则将其print
* mongodb和mysql的区别以及各自的优劣
* wrk的IO复用是怎么做的，IO复用节省了什么资源
* 为什么jmeter的并发上不去
* tcp四次挥手的时候FIN-WAIT状态出现在客户端还是服务端
* c++多态如何实现，编译器怎么实现虚函数
* c++的map数据结构是什么，java中hashmap和treemap各自的数据结构和插入查询复杂度是多少，hashmap怎么解决hash冲突
* 一个数组，只有一个数据出现一次，其他数据都出现两次，找出出现一次的数据，并计算复杂度
  * 对所有数据做异或操作，最后的数就是只出现一次的数
* go携程如何实现（问胡子昂）