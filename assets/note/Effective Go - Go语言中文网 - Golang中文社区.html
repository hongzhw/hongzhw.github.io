<!DOCTYPE html>
<!-- saved from url=(0037)https://studygolang.com/articles/1976 -->
<html lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Effective Go  - Go语言中文网 - Golang中文社区</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
	<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
	
	<link rel="shortcut icon" href="https://static.studygolang.com/img/favicon.ico">
	<link rel="apple-touch-icon" type="image/png" href="https://static.studygolang.com/static/img/logo2.png">
	<meta name="keywords" content="Go,Golang,Go语言">
<meta name="description" content="转自：https://golang.org/doc/effective_go.html Effective Go IntroductionExamplesFormattingCommentaryNamesPackage namesGettersInterface namesMixedCapsSemicolonsControl structuresIfRedeclaration and reassi">
	<meta name="author" content="polaris &lt;polaris@studygolang.com&gt;">
	<link rel="canonical" href="https://studygolang.com/">

	
	<link rel="stylesheet" href="./Effective Go - Go语言中文网 - Golang中文社区_files/fonts_googleapi.css">
	<link rel="stylesheet" href="./Effective Go - Go语言中文网 - Golang中文社区_files/cosmo_bootstrap.min.css">
	<link rel="stylesheet" href="./Effective Go - Go语言中文网 - Golang中文社区_files/font-awesome.min.css">
	<link rel="stylesheet" href="./Effective Go - Go语言中文网 - Golang中文社区_files/sg_libs.min.css">
	<link rel="stylesheet" href="./Effective Go - Go语言中文网 - Golang中文社区_files/sg_styles.min.css">
	
	

<style>
pre .line { margin: auto; line-height: 20px; border-bottom: none; }
.image-package .image-container-fill { padding-bottom: 0 !important; }
</style>



<link href="./Effective Go - Go语言中文网 - Golang中文社区_files/prism-okaidia.min.css" rel="stylesheet">
<link href="./Effective Go - Go语言中文网 - Golang中文社区_files/prism-line-numbers.min.css" rel="stylesheet">



	
	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/reactive_library.js.下载"></script><script src="./Effective Go - Go语言中文网 - Golang中文社区_files/push.js.下载"></script><script src="./Effective Go - Go语言中文网 - Golang中文社区_files/hm.js.下载"></script><script async="" src="./Effective Go - Go语言中文网 - Golang中文社区_files/analytics.js.下载"></script><script src="./Effective Go - Go语言中文网 - Golang中文社区_files/osd.js.下载"></script><script src="./Effective Go - Go语言中文网 - Golang中文社区_files/ca-pub-4512014793067058.js.下载"></script><script src="./Effective Go - Go语言中文网 - Golang中文社区_files/html5shiv.js.下载"></script>
	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/respond.min.js.下载"></script>
	
<link rel="preload" href="./Effective Go - Go语言中文网 - Golang中文社区_files/integrator.js.下载" as="script"><script type="text/javascript" src="./Effective Go - Go语言中文网 - Golang中文社区_files/integrator.js.下载"></script><style>.cke{visibility:hidden;}</style></head>
<body>
	<header class="navbar navbar-default navbar-fixed-top" role="navigation" style="position: fixed;">
		<div class="container">
			
			<div class="navbar-header">
				<a href="https://studygolang.com/" class="navbar-brand" title="Go语言中文网"><img alt="Go语言中文网" src="./Effective Go - Go语言中文网 - Golang中文社区_files/logo1.png" style="margin-top: -7px; height: 45px;"></a>
				<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar-main">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
			</div>
			<div class="navbar-collapse collapse" id="navbar-main">
				<ul class="nav navbar-nav">
					<li class="">
						<a href="https://studygolang.com/topics">主题</a>
					</li>
					<li class="active">
						<a href="https://studygolang.com/articles">文章</a>
					</li>
					<li class="">
						<a href="https://studygolang.com/projects">项目</a>
					</li>
					<li class="">
						<a href="https://studygolang.com/resources">资源</a>
					</li>
					<li class="">
						<a href="https://studygolang.com/books">图书</a>
					</li>
					<li class="dropdown ">
						
						<a class="dropdown-toggle" data-toggle="dropdown" href="https://studygolang.com/articles/1976#" id="readings">晨读 <span class="caret"></span></a>
						<ul class="dropdown-menu" aria-labelledby="readings">
							<li><a href="https://studygolang.com/readings">Go晨读</a></li>
							<li><a href="https://studygolang.com/readings?rtype=1">综合晨读</a></li>
						</ul>
						
					</li>
					<li class="">
						<a href="https://studygolang.com/dl">下载<i class="newfuture"></i></a>
					</li>
					<li class="dropdown">
						<a class="dropdown-toggle" data-toggle="dropdown" href="https://studygolang.com/articles/1976#" id="docs" aria-expanded="false">官方文档 <span class="caret"></span></a>
						<ul class="dropdown-menu" aria-labelledby="docs">
						
							<li><a href="http://docs.studygolang.com/" target="_blank">英文文档</a></li>
							<li><a href="http://docscn.studygolang.com/" target="_blank">中文文档</a></li>
							<li><a href="https://studygolang.com/pkgdoc">标准库中文版</a></li>
							<li role="presentation" class="divider"></li>
							<li><a href="http://tour.studygolang.com/" target="_blank">Go指南</a></li>
						
						</ul>
					</li>
				</ul>
				<form class="navbar-form navbar-left" action="https://studygolang.com/search" role="search" target="_blank">
					<input type="text" name="q" class="form-control search-query" placeholder="搜索" value="">
				</form>
				<ul class="nav navbar-nav navbar-right" id="userbar">
					
					<li class="first"><a href="https://studygolang.com/account/register">注册</a></li><li class="last"><a href="https://studygolang.com/account/login">登录</a></li>
					
				</ul>
			</div>
		</div>
	</header>
	<div class="wrapper" id="wrapper" style="margin-top: 52px;">
		<div class="container" role="main">
		

			
<div class="row">
	<div class="col-md-9 col-sm-6">
		<div class="sep20"></div>
		<ol class="breadcrumb">
			<li><a href="https://studygolang.com/">首页</a></li>
			<li><a href="https://studygolang.com/articles">文章</a></li>
		</ol>
		<div class="page">
			<div class="box_white">
				<div class="title">
					
					<h1 id="title" data-id="1976">
						Effective Go
					</h1>
					<small class="c9">
					
						
						<span>leonzhouwei</span>
						
					
						 · <span title="2014-12-01 00:00:01" class="timeago">2014-12-01 00:00:01</span> · 8097 次点击 · 
						<span class="read-time">预计阅读时间 73 分钟</span> · 
						<span class="timeago" title="2018-07-27 17:31:16">大约3小时之前</span> 开始浏览 &nbsp; &nbsp;
					
					</small>
				</div>
				
				<div class="outdated">这是一个创建于 <span title="2014-12-01 00:00:01" class="timeago">2014-12-01 00:00:01</span> 的文章，其中的信息可能已经有所发展或是发生改变。</div>
				
				<div class="cell">
					
					<div id="myeditor" class="content article-entry">
						<p>转自：<a target="_blank" href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a></p>
<h1 style="margin:20px 0px; padding:0px; color:rgb(55,94,171); font-size:24px; font-family:Helvetica,Arial,sans-serif">
Effective Go</h1>
<div id="nav" style="color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
<div class="table-responsive"><table class="unruled table">
<tbody>
<tr>
<td class="first" style="vertical-align:top">
<dl style="margin:20px; font-size:14px"><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#introduction" style="color:rgb(55,94,171); text-decoration:none">Introduction</a></dt><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#examples" style="color:rgb(55,94,171); text-decoration:none">Examples</a></dd><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#formatting" style="color:rgb(55,94,171); text-decoration:none">Formatting</a></dt><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#commentary" style="color:rgb(55,94,171); text-decoration:none">Commentary</a></dt><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#names" style="color:rgb(55,94,171); text-decoration:none">Names</a></dt><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#package-names" style="color:rgb(55,94,171); text-decoration:none">Package names</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#Getters" style="color:rgb(55,94,171); text-decoration:none">Getters</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#interface-names" style="color:rgb(55,94,171); text-decoration:none">Interface names</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#mixed-caps" style="color:rgb(55,94,171); text-decoration:none">MixedCaps</a></dd><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#semicolons" style="color:rgb(55,94,171); text-decoration:none">Semicolons</a></dt><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#control-structures" style="color:rgb(55,94,171); text-decoration:none">Control structures</a></dt><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#if" style="color:rgb(55,94,171); text-decoration:none">If</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#redeclaration" style="color:rgb(55,94,171); text-decoration:none">Redeclaration and reassignment</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#for" style="color:rgb(55,94,171); text-decoration:none">For</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#switch" style="color:rgb(55,94,171); text-decoration:none">Switch</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#type_switch" style="color:rgb(55,94,171); text-decoration:none">Type switch</a></dd><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#functions" style="color:rgb(55,94,171); text-decoration:none">Functions</a></dt><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#multiple-returns" style="color:rgb(55,94,171); text-decoration:none">Multiple return values</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#named-results" style="color:rgb(55,94,171); text-decoration:none">Named result parameters</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#defer" style="color:rgb(55,94,171); text-decoration:none">Defer</a></dd><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#data" style="color:rgb(55,94,171); text-decoration:none">Data</a></dt><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#allocation_new" style="color:rgb(55,94,171); text-decoration:none">Allocation with new</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#composite_literals" style="color:rgb(55,94,171); text-decoration:none">Constructors and composite literals</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#allocation_make" style="color:rgb(55,94,171); text-decoration:none">Allocation with make</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#arrays" style="color:rgb(55,94,171); text-decoration:none">Arrays</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#slices" style="color:rgb(55,94,171); text-decoration:none">Slices</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#two_dimensional_slices" style="color:rgb(55,94,171); text-decoration:none">Two-dimensional slices</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#maps" style="color:rgb(55,94,171); text-decoration:none">Maps</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#printing" style="color:rgb(55,94,171); text-decoration:none">Printing</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#append" style="color:rgb(55,94,171); text-decoration:none">Append</a></dd><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#initialization" style="color:rgb(55,94,171); text-decoration:none">Initialization</a></dt></dl>
</td>
<td style="vertical-align:top">
<dl style="margin:20px; font-size:14px"><dd style="margin:2px 20px; font-size:14px">
<a target="_blank" href="https://golang.org/doc/effective_go.html#constants" style="color:rgb(55,94,171); text-decoration:none">Constants</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#variables" style="color:rgb(55,94,171); text-decoration:none">Variables</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#init" style="color:rgb(55,94,171); text-decoration:none">The init function</a></dd><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#methods" style="color:rgb(55,94,171); text-decoration:none">Methods</a></dt><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#pointers_vs_values" style="color:rgb(55,94,171); text-decoration:none">Pointers vs. Values</a></dd><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#interfaces_and_types" style="color:rgb(55,94,171); text-decoration:none">Interfaces and other types</a></dt><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#interfaces" style="color:rgb(55,94,171); text-decoration:none">Interfaces</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#conversions" style="color:rgb(55,94,171); text-decoration:none">Conversions</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#interface_conversions" style="color:rgb(55,94,171); text-decoration:none">Interface conversions and type assertions</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#generality" style="color:rgb(55,94,171); text-decoration:none">Generality</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#interface_methods" style="color:rgb(55,94,171); text-decoration:none">Interfaces and methods</a></dd><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#blank" style="color:rgb(55,94,171); text-decoration:none">The blank identifier</a></dt><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#blank_assign" style="color:rgb(55,94,171); text-decoration:none">The blank identifier in multiple assignment</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#blank_unused" style="color:rgb(55,94,171); text-decoration:none">Unused imports and variables</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#blank_import" style="color:rgb(55,94,171); text-decoration:none">Import for side effect</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#blank_implements" style="color:rgb(55,94,171); text-decoration:none">Interface checks</a></dd><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#embedding" style="color:rgb(55,94,171); text-decoration:none">Embedding</a></dt><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#concurrency" style="color:rgb(55,94,171); text-decoration:none">Concurrency</a></dt><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#sharing" style="color:rgb(55,94,171); text-decoration:none">Share by communicating</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#goroutines" style="color:rgb(55,94,171); text-decoration:none">Goroutines</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#channels" style="color:rgb(55,94,171); text-decoration:none">Channels</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#chan_of_chan" style="color:rgb(55,94,171); text-decoration:none">Channels of channels</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#parallel" style="color:rgb(55,94,171); text-decoration:none">Parallelization</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#leaky_buffer" style="color:rgb(55,94,171); text-decoration:none">A leaky buffer</a></dd><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#errors" style="color:rgb(55,94,171); text-decoration:none">Errors</a></dt><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#panic" style="color:rgb(55,94,171); text-decoration:none">Panic</a></dd><dd style="margin:2px 20px; font-size:14px"><a target="_blank" href="https://golang.org/doc/effective_go.html#recover" style="color:rgb(55,94,171); text-decoration:none">Recover</a></dd><dt><a target="_blank" href="https://golang.org/doc/effective_go.html#web_server" style="color:rgb(55,94,171); text-decoration:none">A web server</a></dt></dl>
</td>
</tr>
</tbody>
</table></div>
</div>
<h2 id="introduction" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Introduction</h2>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Go is a new language. Although it borrows ideas from existing languages, it has unusual properties that make effective Go programs different in character from programs written in its relatives. A straightforward translation of a C++ or Java program into Go
 is unlikely to produce a satisfactory result—Java programs are written in Java, not Go. On the other hand, thinking about the problem from a Go perspective could produce a successful but quite different program. In other words, to write Go well, it's important
 to understand its properties and idioms. It's also important to know the established conventions for programming in Go, such as naming, formatting, program construction, and so on, so that programs you write will be easy for other Go programmers to understand.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
This document gives tips for writing clear, idiomatic Go code. It augments the&nbsp;<a target="_blank" href="https://golang.org/ref/spec" style="color:rgb(55,94,171); text-decoration:none">language specification</a>, the&nbsp;<a target="_blank" href="https://tour.golang.org/" style="color:rgb(55,94,171); text-decoration:none">Tour
 of Go</a>, and&nbsp;<a target="_blank" href="https://golang.org/doc/code.html" style="color:rgb(55,94,171); text-decoration:none">How to Write Go Code</a>, all of which you should read first.</p>
<h3 id="examples" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Examples</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The&nbsp;<a target="_blank" href="https://golang.org/src/pkg/" style="color:rgb(55,94,171); text-decoration:none">Go package sources</a>&nbsp;are intended to serve not only as the core library but also as examples of how to use the language. Moreover, many of the packages
 contain working, self-contained executable examples you can run directly from the&nbsp;<a target="_blank" href="https://golang.org/" style="color:rgb(55,94,171); text-decoration:none">golang.org</a>&nbsp;web site, such as&nbsp;<a target="_blank" href="https://golang.org/pkg/strings/#example_Map" style="color:rgb(55,94,171); text-decoration:none">this
 one</a>&nbsp;(if necessary, click on the word "Example" to open it up). If you have a question about how to approach a problem or how something might be implemented, the documentation, code and examples in the library can provide answers, ideas and background.</p>
<h2 id="formatting" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Formatting</h2>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Formatting issues are the most contentious but the least consequential. People can adapt to different formatting styles but it's better if they don't have to, and less time is devoted to the topic if everyone adheres to the same style. The problem is how to
 approach this Utopia without a long prescriptive style guide.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
With Go we take an unusual approach and let the machine take care of most formatting issues. The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">gofmt</code>&nbsp;program (also available as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">go fmt</code>,
 which operates at the package level rather than source file level) reads a Go program and emits the source in a standard style of indentation and vertical alignment, retaining and if necessary reformatting comments. If you want to know how to handle some new
 layout situation, run&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">gofmt</code>; if the answer doesn't seem right, rearrange your program (or file a bug about&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">gofmt</code>), don't work
 around it.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
As an example, there's no need to spend time lining up the comments on the fields of a structure.&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Gofmt</code>&nbsp;will do that for you. Given the declaration</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type T struct {
    name string // name of the object
    value int // its value
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
<code style="font-family:Menlo,monospace; font-size:14px">gofmt</code>&nbsp;will line up the columns:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type T struct {
    name    string // name of the object
    value   int    // its value
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
All Go code in the standard packages has been formatted with&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">gofmt</code>.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Some formatting details remain. Very briefly:</p>
<dl style="margin:20px; font-size:14px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif">
<dt>Indentation</dt><dd style="margin:2px 20px; font-size:14px">We use tabs for indentation and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">gofmt</code>&nbsp;emits them by default. Use spaces only if you must.</dd><dt>Line length</dt><dd style="margin:2px 20px; font-size:14px">Go has no line length limit. Don't worry about overflowing a punched card. If a line feels too long, wrap it and indent with an extra tab.</dd><dt>Parentheses</dt><dd style="margin:2px 20px; font-size:14px">Go needs fewer parentheses than C and Java: control structures (<code style="font-family:Menlo,monospace; font-size:14px">if</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">for</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">switch</code>)
 do not have parentheses in their syntax. Also, the operator precedence hierarchy is shorter and clearer, so
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; background:rgb(233,233,233)">x&lt;&lt;8 + y&lt;&lt;16
</pre>
means what the spacing implies, unlike in the other languages.</dd></dl>
<h2 id="commentary" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Commentary</h2>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Go provides C-style&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">/* */</code>&nbsp;block comments and C++-style&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">//</code>&nbsp;line comments. Line comments are the norm; block comments appear mostly
 as package comments, but are useful within an expression or to disable large swaths of code.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The program—and web server—<code style="font-family:Menlo,monospace; font-size:14px">godoc</code>&nbsp;processes Go source files to extract documentation about the contents of the package. Comments that appear before top-level declarations, with no intervening newlines,
 are extracted along with the declaration to serve as explanatory text for the item. The nature and style of these comments determines the quality of the documentation&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">godoc</code>&nbsp;produces.</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-4512014793067058" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_3_expand" style="display:inline-table;border:none;height:200px;margin:0;padding:0;position:relative;visibility:visible;width:837px;background-color:transparent;"><ins id="aswift_3_anchor" style="display:block;border:none;height:200px;margin:0;padding:0;position:relative;visibility:visible;width:837px;background-color:transparent;"><iframe width="837" height="200" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_3" name="aswift_3" style="left:0;position:absolute;top:0;width:837px;height:200px;" src="./Effective Go - Go语言中文网 - Golang中文社区_files/saved_resource.html"></iframe></ins></ins></ins></div>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Every package should have a&nbsp;<em>package comment</em>, a block comment preceding the package clause. For multi-file packages, the package comment only needs to be present in one file, and any one will do. The package comment should introduce the package and
 provide information relevant to the package as a whole. It will appear first on the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">godoc</code>&nbsp;page and should set up the detailed documentation that follows.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">/*
Package regexp implements a simple library for regular expressions.

The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If the package is simple, the package comment can be brief.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Package path implements utility routines for
// manipulating slash-separated filename paths.
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Comments do not need extra formatting such as banners of stars. The generated output may not even be presented in a fixed-width font, so don't depend on spacing for alignment—<code style="font-family:Menlo,monospace; font-size:14px">godoc</code>, like&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">gofmt</code>,
 takes care of that. The comments are uninterpreted plain text, so HTML and other annotations such as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">_this_</code>&nbsp;will reproduce&nbsp;<em>verbatim</em>&nbsp;and should not be used. One adjustment&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">godoc</code>&nbsp;does
 do is to display indented text in a fixed-width font, suitable for program snippets. The package comment for the&nbsp;<a target="_blank" href="https://golang.org/pkg/fmt/" style="color:rgb(55,94,171); text-decoration:none"><code style="font-family:Menlo,monospace; font-size:14px">fmt</code>package</a>&nbsp;uses
 this to good effect.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Depending on the context,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">godoc</code>&nbsp;might not even reformat comments, so make sure they look good straight up: use correct spelling, punctuation, and sentence structure, fold long lines, and so on.</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-4512014793067058" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_4_expand" style="display:inline-table;border:none;height:200px;margin:0;padding:0;position:relative;visibility:visible;width:837px;background-color:transparent;"><ins id="aswift_4_anchor" style="display:block;border:none;height:200px;margin:0;padding:0;position:relative;visibility:visible;width:837px;background-color:transparent;"><iframe width="837" height="200" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_4" name="aswift_4" style="left:0;position:absolute;top:0;width:837px;height:200px;" src="./Effective Go - Go语言中文网 - Golang中文社区_files/saved_resource(1).html"></iframe></ins></ins></ins></div>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Inside a package, any comment immediately preceding a top-level declaration serves as a&nbsp;<em>doc comment</em>&nbsp;for that declaration. Every exported (capitalized) name in a program should have a doc comment.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Doc comments work best as complete sentences, which allow a wide variety of automated presentations. The first sentence should be a one-sentence summary that starts with the name being declared.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Compile parses a regular expression and returns, if successful, a Regexp
// object that can be used to match against text.
func Compile(str string) (regexp *Regexp, err error) {
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If the name always begins the comment, the output of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">godoc</code>&nbsp;can usefully be run through&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">grep</code>. Imagine you couldn't remember the
 name "Compile" but were looking for the parsing function for regular expressions, so you ran the command,</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">$ godoc regexp | grep parse
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If all the doc comments in the package began, "This function...",&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">grep</code>&nbsp;wouldn't help you remember the name. But because the package starts each doc comment with the name, you'd see something like
 this, which recalls the word you're looking for.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">$ godoc regexp | grep parse
    Compile parses a regular expression and returns, if successful, a Regexp
    parsed. It simplifies safe initialization of global variables holding
    cannot be parsed. It simplifies safe initialization of global variables
$
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Go's declaration syntax allows grouping of declarations. A single doc comment can introduce a group of related constants or variables. Since the whole declaration is presented, such a comment can often be perfunctory.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Error codes returned by failures to parse an expression.
var (
    ErrInternal      = errors.New("regexp: internal error")
    ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
    ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
    ...
)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Grouping can also indicate relationships between items, such as the fact that a set of variables is protected by a mutex.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
</pre>
<h2 id="names" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Names</h2>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Names are as important in Go as in any other language. They even have semantic effect: the visibility of a name outside a package is determined by whether its first character is upper case. It's therefore worth spending a little time talking about naming conventions
 in Go programs.</p>
<h3 id="package-names" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Package names</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
When a package is imported, the package name becomes an accessor for the contents. After</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">import "bytes"
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
the importing package can talk about&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bytes.Buffer</code>. It's helpful if everyone using the package can use the same name to refer to its contents, which implies that the package name should be good:
 short, concise, evocative. By convention, packages are given lower case, single-word names; there should be no need for underscores or mixedCaps. Err on the side of brevity, since everyone using your package will be typing that name. And don't worry about
 collisions&nbsp;<em>a priori</em>. The package name is only the default name for imports; it need not be unique across all source code, and in the rare case of a collision the importing package can choose a different name to use locally. In any case, confusion
 is rare because the file name in the import determines just which package is being used.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Another convention is that the package name is the base name of its source directory; the package in&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">src/pkg/encoding/base64</code>&nbsp;is imported as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">"encoding/base64"</code>&nbsp;but
 has name&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">base64</code>, not&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">encoding_base64</code>&nbsp;and not&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">encodingBase64</code>.</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-4512014793067058" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_5_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 837px; background-color: transparent;"><ins id="aswift_5_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 837px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="837" height="200" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_5" name="aswift_5" style="left:0;position:absolute;top:0;width:837px;height:200px;" src="./Effective Go - Go语言中文网 - Golang中文社区_files/saved_resource(2).html"></iframe></ins></ins></ins></div>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid stutter. (Don't use the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">import .</code>&nbsp;notation, which can simplify
 tests that must run outside the package they are testing, but should otherwise be avoided.) For instance, the buffered reader type in the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bufio</code>&nbsp;package is called&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Reader</code>,
 not&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">BufReader</code>, because users see it as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bufio.Reader</code>, which is a clear, concise name. Moreover, because imported entities are always
 addressed with their package name,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bufio.Reader</code>&nbsp;does not conflict with&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.Reader</code>. Similarly, the function to make new instances
 of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ring.Ring</code>—which is the definition of a&nbsp;<em>constructor</em>&nbsp;in Go—would normally be called&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">NewRing</code>, but since&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Ring</code>&nbsp;is
 the only type exported by the package, and since the package is called&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ring</code>, it's called just&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">New</code>, which clients of the package
 see as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ring.New</code>. Use the package structure to help you choose good names.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Another short example is&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">once.Do</code>;&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">once.Do(setup)</code>&nbsp;reads well and would not be improved by writing&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">once.DoOrWaitUntilDone(setup)</code>.
 Long names don't automatically make things more readable. A helpful doc comment can often be more valuable than an extra long name.</p>
<h3 id="Getters" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Getters</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Go doesn't provide automatic support for getters and setters. There's nothing wrong with providing getters and setters yourself, and it's often appropriate to do so, but it's neither idiomatic nor necessary to put&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Get</code>&nbsp;into
 the getter's name. If you have a field called&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">owner</code>&nbsp;(lower case, unexported), the getter method should be called&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Owner</code>&nbsp;(upper
 case, exported), not&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">GetOwner</code>. The use of upper-case names for export provides the hook to discriminate the field from the method. A setter function, if needed, will likely be called&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">SetOwner</code>.
 Both names read well in practice:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
</pre>
<h3 id="interface-names" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Interface names</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
By convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun:&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Reader</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Writer</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Formatter</code>,<code style="font-family:Menlo,monospace; font-size:14px">CloseNotifier</code>&nbsp;etc.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
There are a number of such names and it's productive to honor them and the function names they capture.&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Read</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Write</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Close</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Flush</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">String</code>&nbsp;and
 so on have canonical signatures and meanings. To avoid confusion, don't give your method one of those names unless it has the same signature and meaning. Conversely, if your type implements a method with the same meaning as a method on a well-known type, give
 it the same name and signature; call your string-converter method&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">String</code>&nbsp;not<code style="font-family:Menlo,monospace; font-size:14px">ToString</code>.</p>
<h3 id="mixed-caps" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
MixedCaps</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Finally, the convention in Go is to use&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">MixedCaps</code>&nbsp;or&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">mixedCaps</code>&nbsp;rather than underscores to write multiword names.</p>
<h2 id="semicolons" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Semicolons</h2>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Like C, Go's formal grammar uses semicolons to terminate statements, but unlike in C, those semicolons do not appear in the source. Instead the lexer uses a simple rule to insert semicolons automatically as it scans, so the input text is mostly free of them.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The rule is this. If the last token before a newline is an identifier (which includes words like&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">int</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">float64</code>), a basic literal
 such as a number or string constant, or one of the tokens</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">break continue fallthrough return ++ -- ) }
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
the lexer always inserts a semicolon after the token. This could be summarized as, “if the newline comes after a token that could end a statement, insert a semicolon”.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
A semicolon can also be omitted immediately before a closing brace, so a statement such as</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">    go func() { for { dst &lt;- &lt;-src } }()
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
needs no semicolons. Idiomatic Go programs have semicolons only in places such as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">for</code>&nbsp;loop clauses, to separate the initializer, condition, and continuation elements. They are also necessary to
 separate multiple statements on a line, should you write code that way.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
One consequence of the semicolon insertion rules is that you cannot put the opening brace of a control structure (<code style="font-family:Menlo,monospace; font-size:14px">if</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">for</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">switch</code>,
 or&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">select</code>) on the next line. If you do, a semicolon will be inserted before the brace, which could cause unwanted effects. Write them like this</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">if i &lt; f() {
    g()
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
not like this</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">if i &lt; f()  // wrong!
{           // wrong!
    g()
}
</pre>
<h2 id="control-structures" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Control structures</h2>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The control structures of Go are related to those of C but differ in important ways. There is no&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">do</code>&nbsp;or&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">while</code>&nbsp;loop, only a slightly
 generalized&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">for</code>;&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">switch</code>&nbsp;is more flexible;&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">if</code>&nbsp;and<code style="font-family:Menlo,monospace; font-size:14px">switch</code>&nbsp;accept
 an optional initialization statement like that of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">for</code>;&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">break</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">continue</code>&nbsp;statements
 take an optional label to identify what to break or continue; and there are new control structures including a type switch and a multiway communications multiplexer,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">select</code>. The syntax is also
 slightly different: there are no parentheses and the bodies must always be brace-delimited.</p>
<h3 id="if" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
If</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In Go a simple&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">if</code>&nbsp;looks like this:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">if x &gt; 0 {
    return y
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Mandatory braces encourage writing simple&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">if</code>&nbsp;statements on multiple lines. It's good style to do so anyway, especially when the body contains a control statement such as a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">return</code>&nbsp;or&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">break</code>.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Since&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">if</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">switch</code>&nbsp;accept an initialization statement, it's common to see one used to set up a local variable.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
</pre>
<p id="else" style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In the Go libraries, you'll find that when an&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">if</code>&nbsp;statement doesn't flow into the next statement—that is, the body ends in&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">break</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">continue</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">goto</code>,
 or&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">return</code>—the unnecessary&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">else</code>is omitted.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
This is an example of a common situation where code must guard against a sequence of error conditions. The code reads well if the successful flow of control runs down the page, eliminating error cases as they arise. Since error cases tend to end in&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">return</code>&nbsp;statements,
 the resulting code needs no&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">else</code>&nbsp;statements.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
</pre>
<h3 id="redeclaration" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Redeclaration and reassignment</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
An aside: The last example in the previous section demonstrates a detail of how the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">:=</code>&nbsp;short declaration form works. The declaration that calls&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">os.Open</code>&nbsp;reads,</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">f, err := os.Open(name)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
This statement declares two variables,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">f</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">err</code>. A few lines later, the call to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">f.Stat</code>&nbsp;reads,</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">d, err := f.Stat()
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
which looks as if it declares&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">d</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">err</code>. Notice, though, that&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">err</code>&nbsp;appears
 in both statements. This duplication is legal:&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">err</code>&nbsp;is declared by the first statement, but only&nbsp;<em>re-assigned</em>&nbsp;in the second. This means that the call to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">f.Stat</code>&nbsp;uses
 the existing&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">err</code>&nbsp;variable declared above, and just gives it a new value.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">:=</code>&nbsp;declaration a variable&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">v</code>&nbsp;may appear even if it has already been declared, provided:</p>
<ul style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
<li>this declaration is in the same scope as the existing declaration of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">v</code>&nbsp;(if&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">v</code>&nbsp;is already declared in an outer scope, the declaration
 will create a new variable §),</li><li>the corresponding value in the initialization is assignable to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">v</code>, and</li><li>there is at least one other variable in the declaration that is being declared anew.</li></ul>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
This unusual property is pure pragmatism, making it easy to use a single&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">err</code>&nbsp;value, for example, in a long&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">if-else</code>&nbsp;chain. You'll
 see it used often.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
§ It's worth noting here that in Go the scope of function parameters and return values is the same as the function body, even though they appear lexically outside the braces that enclose the body.</p>
<h3 id="for" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
For</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The Go&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">for</code>&nbsp;loop is similar to—but not the same as—C's. It unifies&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">for</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">while</code>&nbsp;and
 there is no&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">do-while</code>. There are three forms, only one of which has semicolons.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Short declarations make it easy to declare the index variable right in the loop.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">sum := 0
for i := 0; i &lt; 10; i++ {
    sum += i
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If you're looping over an array, slice, string, or map, or reading from a channel, a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">range</code>&nbsp;clause can manage the loop.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">for key, value := range oldMap {
    newMap[key] = value
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If you only need the first item in the range (the key or index), drop the second:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If you only need the second item in the range (the value), use the&nbsp;<em>blank identifier</em>, an underscore, to discard the first:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">sum := 0
for _, value := range array {
    sum += value
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The blank identifier has many uses, as described in&nbsp;<a target="_blank" href="https://golang.org/doc/effective_go.html#blank" style="color:rgb(55,94,171); text-decoration:none">a later section</a>.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
For strings, the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">range</code>&nbsp;does more work for you, breaking out individual Unicode code points by parsing the UTF-8. Erroneous encodings consume one byte and produce the replacement rune U+FFFD. (The
 name (with associated builtin type)&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">rune</code>&nbsp;is Go terminology for a single Unicode code point. See&nbsp;<a target="_blank" href="https://golang.org/ref/spec#Rune_literals" style="color:rgb(55,94,171); text-decoration:none">the
 language specification</a>&nbsp;for details.) The loop</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">for pos, char := range "日本\x80語" { // \x80 is an illegal UTF-8 encoding
    fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
prints</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Finally, Go has no comma operator and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">++</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">--</code>&nbsp;are statements not expressions. Thus if you want to run multiple variables in a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">for</code>&nbsp;you
 should use parallel assignment (although that precludes&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">++</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">--</code>).</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Reverse a
for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
</pre>
<h3 id="switch" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Switch</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Go's&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">switch</code>&nbsp;is more general than C's. The expressions need not be constants or even integers, the cases are evaluated top to bottom until a match is found, and if the<code style="font-family:Menlo,monospace; font-size:14px">switch</code>&nbsp;has
 no expression it switches on&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">true</code>. It's therefore possible—and idiomatic—to write an&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">if</code>-<code style="font-family:Menlo,monospace; font-size:14px">else</code>-<code style="font-family:Menlo,monospace; font-size:14px">if</code>-<code style="font-family:Menlo,monospace; font-size:14px">else</code>&nbsp;chain
 as a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">switch</code>.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func unhex(c byte) byte {
    switch {
    case '0' &lt;= c &amp;&amp; c &lt;= '9':
        return c - '0'
    case 'a' &lt;= c &amp;&amp; c &lt;= 'f':
        return c - 'a' + 10
    case 'A' &lt;= c &amp;&amp; c &lt;= 'F':
        return c - 'A' + 10
    }
    return 0
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
There is no automatic fall through, but cases can be presented in comma-separated lists.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&amp;', '=', '#', '+', '%':
        return true
    }
    return false
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Although they are not nearly as common in Go as some other C-like languages,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">break</code>&nbsp;statements can be used to terminate a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">switch</code>&nbsp;early.
 Sometimes, though, it's necessary to break out of a surrounding loop, not the switch, and in Go that can be accomplished by putting a label on the loop and "breaking" to that label. This example shows both uses.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">Loop:
	for n := 0; n &lt; len(src); n += size {
		switch {
		case src[n] &lt; sizeOne:
			if validateOnly {
				break
			}
			size = 1
			update(src[n])

		case src[n] &lt; sizeTwo:
			if n+1 &gt;= len(src) {
				err = errShortInput
				break Loop
			}
			if validateOnly {
				break
			}
			size = 2
			update(src[n] + src[n+1]&lt;&lt;shift)
		}
	}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Of course, the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">continue</code>&nbsp;statement also accepts an optional label but it applies only to loops.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
To close this section, here's a comparison routine for byte slices that uses two&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">switch</code>&nbsp;statements:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Compare returns an integer comparing the two byte slices,
// lexicographically.
// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b
func Compare(a, b []byte) int {
    for i := 0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ {
        switch {
        case a[i] &gt; b[i]:
            return 1
        case a[i] &lt; b[i]:
            return -1
        }
    }
    switch {
    case len(a) &gt; len(b):
        return 1
    case len(a) &lt; len(b):
        return -1
    }
    return 0
}
</pre>
<h3 id="type_switch" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Type switch</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
A switch can also be used to discover the dynamic type of an interface variable. Such a&nbsp;<em>type switch</em>&nbsp;uses the syntax of a type assertion with the keyword&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">type</code>&nbsp;inside the parentheses. If
 the switch declares a variable in the expression, the variable will have the corresponding type in each clause. It's also idiomatic to reuse the name in such cases, in effect declaring a new variable with the same name but a different type in each case.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf("unexpected type %T", t)       // %T prints whatever type t has
case bool:
    fmt.Printf("boolean %t\n", t)             // t has type bool
case int:
    fmt.Printf("integer %d\n", t)             // t has type int
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t) // t has type *bool
case *int:
    fmt.Printf("pointer to integer %d\n", *t) // t has type *int
}
</pre>
<h2 id="functions" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Functions</h2>
<h3 id="multiple-returns" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Multiple return values</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
One of Go's unusual features is that functions and methods can return multiple values. This form can be used to improve on a couple of clumsy idioms in C programs: in-band error returns such as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">-1</code>&nbsp;for&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">EOF</code>&nbsp;and
 modifying an argument passed by address.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In C, a write error is signaled by a negative count with the error code secreted away in a volatile location. In Go,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Write</code>&nbsp;can return a count&nbsp;<em>and</em>&nbsp;an error: “Yes, you wrote some bytes
 but not all of them because you filled the device”. The signature of the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Write</code>&nbsp;method on files from package&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">os</code>&nbsp;is:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func (file *File) Write(b []byte) (n int, err error)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
and as the documentation says, it returns the number of bytes written and a non-nil&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">error</code>&nbsp;when&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">n</code>&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">!=</code>&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">len(b)</code>.
 This is a common style; see the section on error handling for more examples.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
A similar approach obviates the need to pass a pointer to a return value to simulate a reference parameter. Here's a simple-minded function to grab a number from a position in a byte slice, returning the number and the next position.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func nextInt(b []byte, i int) (int, int) {
    for ; i &lt; len(b) &amp;&amp; !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i &lt; len(b) &amp;&amp; isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - '0'
    }
    return x, i
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
You could use it to scan the numbers in an input slice&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">b</code>&nbsp;like this:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">    for i := 0; i &lt; len(b); {
        x, i = nextInt(b, i)
        fmt.Println(x)
    }
</pre>
<h3 id="named-results" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Named result parameters</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The return or result "parameters" of a Go function can be given names and used as regular variables, just like the incoming parameters. When named, they are initialized to the zero values for their types when the function begins; if the function executes a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">return</code>&nbsp;statement
 with no arguments, the current values of the result parameters are used as the returned values.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The names are not mandatory but they can make code shorter and clearer: they're documentation. If we name the results of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">nextInt</code>&nbsp;it becomes obvious which returned&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">int</code>is
 which.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func nextInt(b []byte, pos int) (value, nextPos int) {
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Because named results are initialized and tied to an unadorned return, they can simplify as well as clarify. Here's a version of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.ReadFull</code>&nbsp;that uses them well:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) &gt; 0 &amp;&amp; err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
</pre>
<h3 id="defer" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Defer</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Go's&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">defer</code>&nbsp;statement schedules a function call (the&nbsp;<em>deferred</em>&nbsp;function) to be run immediately before the function executing the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">defer</code>&nbsp;returns.
 It's an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return. The canonical examples are unlocking a mutex or closing a file.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Deferring a call to a function such as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Close</code>&nbsp;has two advantages. First, it guarantees that you will never forget to close the file, a mistake that's easy to make if you later edit the function
 to add a new return path. Second, it means that the close sits near the open, which is much clearer than placing it at the end of the function.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The arguments to the deferred function (which include the receiver if the function is a method) are evaluated when the&nbsp;<em>defer</em>&nbsp;executes, not when the&nbsp;<em>call</em>&nbsp;executes. Besides avoiding worries about variables changing values as the function executes,
 this means that a single deferred call site can defer multiple function executions. Here's a silly example.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">for i := 0; i &lt; 5; i++ {
    defer fmt.Printf("%d ", i)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Deferred functions are executed in LIFO order, so this code will cause&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">4 3 2 1 0</code>&nbsp;to be printed when the function returns. A more plausible example is a simple way to trace function execution through
 the program. We could write a couple of simple tracing routines like this:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// Use them like this:
func a() {
    trace("a")
    defer untrace("a")
    // do something....
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
We can do better by exploiting the fact that arguments to deferred functions are evaluated when the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">defer</code>&nbsp;executes. The tracing routine can set up the argument to the untracing routine. This example:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func trace(s string) string {
    fmt.Println("entering:", s)
    return s
}

func un(s string) {
    fmt.Println("leaving:", s)
}

func a() {
    defer un(trace("a"))
    fmt.Println("in a")
}

func b() {
    defer un(trace("b"))
    fmt.Println("in b")
    a()
}

func main() {
    b()
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
prints</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">entering: b
in b
entering: a
in a
leaving: a
leaving: b
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
For programmers accustomed to block-level resource management from other languages,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">defer</code>&nbsp;may seem peculiar, but its most interesting and powerful applications come precisely from the fact that
 it's not block-based but function-based. In the section on&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">panic</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">recover</code>&nbsp;we'll see another example of its possibilities.</p>
<h2 id="data" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Data</h2>
<h3 id="allocation_new" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Allocation with&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">new</code></h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Go has two allocation primitives, the built-in functions&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">new</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">make</code>. They do different things and apply to different types, which
 can be confusing, but the rules are simple. Let's talk about&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">new</code>&nbsp;first. It's a built-in function that allocates memory, but unlike its namesakes in some other languages it does not&nbsp;<em>initialize</em>&nbsp;the
 memory, it only&nbsp;<em>zeros</em>&nbsp;it. That is,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">new(T)</code>&nbsp;allocates zeroed storage for a new item of type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">T</code>&nbsp;and returns its address,
 a value of type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">*T</code>. In Go terminology, it returns a pointer to a newly allocated zero value of type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">T</code>.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Since the memory returned by&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">new</code>&nbsp;is zeroed, it's helpful to arrange when designing your data structures that the zero value of each type can be used without further initialization. This means
 a user of the data structure can create one with&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">new</code>&nbsp;and get right to work. For example, the documentation for&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bytes.Buffer</code>&nbsp;states
 that "the zero value for&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Buffer</code>&nbsp;is an empty buffer ready to use." Similarly,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">sync.Mutex</code>&nbsp;does not have an explicit constructor
 or&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Init</code>&nbsp;method. Instead, the zero value for a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">sync.Mutex</code>&nbsp;is defined to be an unlocked mutex.</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-4512014793067058" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_6_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 837px; background-color: transparent;"><ins id="aswift_6_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 837px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="837" height="200" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_6" name="aswift_6" style="left:0;position:absolute;top:0;width:837px;height:200px;" src="./Effective Go - Go语言中文网 - Golang中文社区_files/saved_resource(3).html"></iframe></ins></ins></ins></div>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The zero-value-is-useful property works transitively. Consider this type declaration.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Values of type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">SyncedBuffer</code>&nbsp;are also ready to use immediately upon allocation or just declaration. In the next snippet, both&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">p</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">v</code>&nbsp;will
 work correctly without further arrangement.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
</pre>
<h3 id="composite_literals" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Constructors and composite literals</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Sometimes the zero value isn't good enough and an initializing constructor is necessary, as in this example derived from package&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">os</code>.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
There's a lot of boiler plate in there. We can simplify it using a&nbsp;<em>composite literal</em>, which is an expression that creates a new instance each time it is evaluated.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &amp;f
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Note that, unlike in C, it's perfectly OK to return the address of a local variable; the storage associated with the variable survives after the function returns. In fact, taking the address of a composite literal allocates a fresh instance each time it is
 evaluated, so we can combine these last two lines.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">    return &amp;File{fd, name, nil, 0}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The fields of a composite literal are laid out in order and must all be present. However, by labeling the elements explicitly as&nbsp;<em>field</em><code style="font-family:Menlo,monospace; font-size:14px">:</code><em>value</em>&nbsp;pairs, the initializers can appear
 in any order, with the missing ones left as their respective zero values. Thus we could say</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">    return &amp;File{fd: fd, name: name}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
As a limiting case, if a composite literal contains no fields at all, it creates a zero value for the type. The expressions&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">new(File)</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">&amp;File{}</code>&nbsp;are
 equivalent.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Composite literals can also be created for arrays, slices, and maps, with the field labels being indices or map keys as appropriate. In these examples, the initializations work regardless of the values of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Enone</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Eio</code>,
 and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Einval</code>, as long as they are distinct.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
</pre>
<h3 id="allocation_make" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Allocation with&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">make</code></h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Back to allocation. The built-in function&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">make(T,&nbsp;</code><em>args</em><code style="font-family:Menlo,monospace; font-size:14px">)</code>&nbsp;serves a purpose different from&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">new(T)</code>.
 It creates slices, maps, and channels only, and it returns an&nbsp;<em>initialized</em>&nbsp;(not<em>zeroed</em>) value of type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">T</code>&nbsp;(not&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">*T</code>).
 The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. A slice, for example, is a three-item descriptor containing a pointer to the data (inside an array), the
 length, and the capacity, and until those items are initialized, the slice is&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">nil</code>. For slices, maps, and channels,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">make</code>&nbsp;initializes
 the internal data structure and prepares the value for use. For instance,</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">make([]int, 10, 100)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
allocates an array of 100 ints and then creates a slice structure with length 10 and a capacity of 100 pointing at the first 10 elements of the array. (When making a slice, the capacity can be omitted; see the section on slices for more information.) In contrast,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">new([]int)</code>&nbsp;returns
 a pointer to a newly allocated, zeroed slice structure, that is, a pointer to a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">nil</code>&nbsp;slice value.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
These examples illustrate the difference between&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">new</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">make</code>.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Remember that&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">make</code>&nbsp;applies only to maps, slices and channels and does not return a pointer. To obtain an explicit pointer allocate with&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">new</code>&nbsp;or
 take the address of a variable explicitly.</p>
<h3 id="arrays" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Arrays</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Arrays are useful when planning the detailed layout of memory and sometimes can help avoid allocation, but primarily they are a building block for slices, the subject of the next section. To lay the foundation for that topic, here are a few words about arrays.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
There are major differences between the ways arrays work in Go and C. In Go,</p>
<ul style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
<li>Arrays are values. Assigning one array to another copies all the elements.</li><li>In particular, if you pass an array to a function, it will receive a&nbsp;<em>copy</em>&nbsp;of the array, not a pointer to it.</li><li>The size of an array is part of its type. The types&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">[10]int</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">[20]int</code>&nbsp;are distinct.</li></ul>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The value property can be useful but also expensive; if you want C-like behavior and efficiency, you can pass a pointer to the array.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&amp;array)  // Note the explicit address-of operator
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
But even this style isn't idiomatic Go. Use slices instead.</p>
<h3 id="slices" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Slices</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Slices hold references to an underlying array, and if you assign one slice to another, both refer to the same array. If a function takes a slice argument, changes it makes to the elements of the slice will be visible to the caller, analogous to passing a pointer
 to the underlying array. A&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Read</code>&nbsp;function can therefore accept a slice argument rather than a pointer and a count; the length within the slice sets an upper limit of how much data to read. Here
 is the signature of the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Read</code>&nbsp;method of the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">File</code>&nbsp;type in package&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">os</code>:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func (file *File) Read(buf []byte) (n int, err error)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The method returns the number of bytes read and an error value, if any. To read into the first 32 bytes of a larger buffer&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">buf</code>,&nbsp;<em>slice</em>&nbsp;(here used as a verb) the buffer.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">    n, err := f.Read(buf[0:32])
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Such slicing is common and efficient. In fact, leaving efficiency aside for the moment, the following snippet would also read the first 32 bytes of the buffer.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">    var n int
    var err error
    for i := 0; i &lt; 32; i++ {
        nbytes, e := f.Read(buf[i:i+1])  // Read one byte.
        if nbytes == 0 || e != nil {
            err = e
            break
        }
        n += nbytes
    }
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The length of a slice may be changed as long as it still fits within the limits of the underlying array; just assign it to a slice of itself. The&nbsp;<em>capacity</em>&nbsp;of a slice, accessible by the built-in function&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">cap</code>,
 reports the maximum length the slice may assume. Here is a function to append data to a slice. If the data exceeds the capacity, the slice is reallocated. The resulting slice is returned. The function uses the fact that&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">len</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">cap</code>&nbsp;are
 legal when applied to the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">nil</code>&nbsp;slice, and return 0.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func Append(slice, data[]byte) []byte {
    l := len(slice)
    if l + len(data) &gt; cap(slice) {  // reallocate
        // Allocate double what's needed, for future growth.
        newSlice := make([]byte, (l+len(data))*2)
        // The copy function is predeclared and works for any slice type.
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    for i, c := range data {
        slice[l+i] = c
    }
    return slice
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
We must return the slice afterwards because, although&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Append</code>&nbsp;can modify the elements of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">slice</code>, the slice itself (the run-time data
 structure holding the pointer, length, and capacity) is passed by value.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The idea of appending to a slice is so useful it's captured by the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">append</code>&nbsp;built-in function. To understand that function's design, though, we need a little more information, so we'll return to
 it later.</p>
<h3 id="two_dimensional_slices" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Two-dimensional slices</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Go's arrays and slices are one-dimensional. To create the equivalent of a 2D array or slice, it is necessary to define an array-of-arrays or slice-of-slices, like this:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type Transform [3][3]float64  // A 3x3 array, really an array of arrays.
type LinesOfText [][]byte     // A slice of byte slices.
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Because slices are variable-length, it is possible to have each inner slice be a different length. That can be a common situation, as in our&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">LinesOfText</code>&nbsp;example: each line has an independent length.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">text := LinesOfText{
	[]byte("Now is the time"),
	[]byte("for all good gophers"),
	[]byte("to bring some fun to the party."),
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Sometimes it's necessary to allocate a 2D slice, a situation that can arise when processing scan lines of pixels, for instance. There are two ways to achieve this. One is to allocate each slice independently; the other is to allocate a single array and point
 the individual slices into it. Which to use depends on your application. If the slices might grow or shrink, they should be allocated independently to avoid overwriting the next line; if not, it can be more efficient to construct the object with a single allocation.
 For reference, here are sketches of the two methods. First, a line at a time:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Allocate the top-level slice.
picture := make([][]uint8, YSize) // One row per unit of y.
// Loop over the rows, allocating the slice for each row.
for i := range picture {
	picture[i] = make([]uint8, XSize)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
And now as one allocation, sliced into lines:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Allocate the top-level slice, the same as before.
picture := make([][]uint8, YSize) // One row per unit of y.
// Allocate one large slice to hold all the pixels.
pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.
// Loop over the rows, slicing each row from the front of the remaining pixels slice.
for i := range picture {
	picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
</pre>
<h3 id="maps" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Maps</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Maps are a convenient and powerful built-in data structure that associate values of one type (the&nbsp;<em>key</em>) with values of another type (the&nbsp;<em>element</em>&nbsp;or&nbsp;<em>value</em>) The key can be of any type for which the equality operator is defined, such
 as integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays. Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references
 to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Maps can be constructed using the usual composite literal syntax with colon-separated key-value pairs, so it's easy to build them during initialization.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">var timeZone = map[string]int{
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Assigning and fetching map values looks syntactically just like doing the same for arrays and slices except that the index doesn't need to be an integer.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">offset := timeZone["EST"]
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
An attempt to fetch a map value with a key that is not present in the map will return the zero value for the type of the entries in the map. For instance, if the map contains integers, looking up a non-existent key will return&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">0</code>.
 A set can be implemented as a map with value type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bool</code>. Set the map entry to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">true</code>&nbsp;to put the value in the set, and then test it
 by simple indexing.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">attended := map[string]bool{
    "Ann": true,
    "Joe": true,
    ...
}

if attended[person] { // will be false if person is not in the map
    fmt.Println(person, "was at the meeting")
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Sometimes you need to distinguish a missing entry from a zero value. Is there an entry for&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">"UTC"</code>&nbsp;or is that the empty string because it's not in the map at all? You can discriminate with a form
 of multiple assignment.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">var seconds int
var ok bool
seconds, ok = timeZone[tz]
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
For obvious reasons this is called the “comma ok” idiom. In this example, if&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">tz</code>&nbsp;is present,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">seconds</code>&nbsp;will be set appropriately and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ok</code>&nbsp;will
 be true; if not,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">seconds</code>&nbsp;will be set to zero and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ok</code>&nbsp;will be false. Here's a function that puts it together with a nice error report:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("unknown time zone:", tz)
    return 0
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
To test for presence in the map without worrying about the actual value, you can use the&nbsp;<a target="_blank" href="https://golang.org/doc/effective_go.html#blank" style="color:rgb(55,94,171); text-decoration:none">blank identifier</a>&nbsp;(<code style="font-family:Menlo,monospace; font-size:14px">_</code>)
 in place of the usual variable for the value.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">_, present := timeZone[tz]
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
To delete a map entry, use the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">delete</code>&nbsp;built-in function, whose arguments are the map and the key to be deleted. It's safe to do this even if the key is already absent from the map.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">delete(timeZone, "PDT")  // Now on Standard Time
</pre>
<h3 id="printing" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Printing</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Formatted printing in Go uses a style similar to C's&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">printf</code>&nbsp;family but is richer and more general. The functions live in the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">fmt</code>&nbsp;package
 and have capitalized names:<code style="font-family:Menlo,monospace; font-size:14px">fmt.Printf</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">fmt.Fprintf</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">fmt.Sprintf</code>&nbsp;and
 so on. The string functions (<code style="font-family:Menlo,monospace; font-size:14px">Sprintf</code>&nbsp;etc.) return a string rather than filling in a provided buffer.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
You don't need to provide a format string. For each of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Printf</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Fprintf</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sprintf</code>&nbsp;there
 is another pair of functions, for instance&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Print</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Println</code>. These functions do not take a format string but instead generate
 a default format for each argument. The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Println</code>&nbsp;versions also insert a blank between arguments and append a newline to the output while the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Print</code>&nbsp;versions
 add blanks only if the operand on neither side is a string. In this example each line produces the same output.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The formatted print functions&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">fmt.Fprint</code>&nbsp;and friends take as a first argument any object that implements the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.Writer</code>&nbsp;interface;
 the variables&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">os.Stdout</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">os.Stderr</code>&nbsp;are familiar instances.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Here things start to diverge from C. First, the numeric formats such as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">%d</code>&nbsp;do not take flags for signedness or size; instead, the printing routines use the type of the argument to decide these
 properties.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">var x uint64 = 1&lt;&lt;64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
prints</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">18446744073709551615 ffffffffffffffff; -1 -1
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If you just want the default conversion, such as decimal for integers, you can use the catchall format&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">%v</code>&nbsp;(for “value”); the result is exactly what&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Print</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Println</code>&nbsp;would
 produce. Moreover, that format can print&nbsp;<em>any</em>&nbsp;value, even arrays, slices, structs, and maps. Here is a print statement for the time zone map defined in the previous section.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">fmt.Printf("%v\n", timeZone)  // or just fmt.Println(timeZone)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
which gives output</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
For maps the keys may be output in any order, of course. When printing a struct, the modified format&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">%+v</code>&nbsp;annotates the fields of the structure with their names, and for any value the alternate
 format&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">%#v</code>&nbsp;prints the value in full Go syntax.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type T struct {
    a int
    b float64
    c string
}
t := &amp;T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
prints</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">&amp;{7 -2.35 abc   def}
&amp;{a:7 b:-2.35 c:abc     def}
&amp;main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string] int{"CST":-21600, "PST":-28800, "EST":-18000, "UTC":0, "MST":-25200}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
(Note the ampersands.) That quoted string format is also available through&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">%q</code>&nbsp;when applied to a value of type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">string</code>&nbsp;or&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">[]byte</code>.
 The alternate format&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">%#q</code>&nbsp;will use backquotes instead if possible. (The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">%q</code>&nbsp;format also applies to integers and runes, producing
 a single-quoted rune constant.) Also,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">%x</code>&nbsp;works on strings, byte arrays and byte slices as well as on integers, generating a long hexadecimal string, and with a space in the format (<code style="font-family:Menlo,monospace; font-size:14px">%&nbsp;x</code>)
 it puts spaces between the bytes.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Another handy format is&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">%T</code>, which prints the&nbsp;<em>type</em>&nbsp;of a value.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">fmt.Printf("%T\n", timeZone)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
prints</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">map[string] int
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If you want to control the default format for a custom type, all that's required is to define a method with the signature&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">String() string</code>&nbsp;on the type. For our simple type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">T</code>,
 that might look like this.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func (t *T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
to print in the format</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">7/-2.35/"abc\tdef"
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
(If you need to print&nbsp;<em>values</em>&nbsp;of type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">T</code>&nbsp;as well as pointers to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">T</code>, the receiver for&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">String</code>&nbsp;must
 be of value type; this example used a pointer because that's more efficient and idiomatic for struct types. See the section below on&nbsp;<a target="_blank" href="https://golang.org/doc/effective_go.html#pointers_vs_values" style="color:rgb(55,94,171); text-decoration:none">pointers
 vs. value receivers</a>&nbsp;for more information.)</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Our&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">String</code>&nbsp;method is able to call&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sprintf</code>&nbsp;because the print routines are fully reentrant and can be wrapped this way. There is
 one important detail to understand about this approach, however: don't construct a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">String</code>&nbsp;method by calling&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sprintf</code>&nbsp;in a way that
 will recur into your&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">String</code>&nbsp;method indefinitely. This can happen if the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sprintf</code>&nbsp;call attempts to print the receiver directly as
 a string, which in turn will invoke the method again. It's a common and easy mistake to make, as this example shows.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type MyString string

func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", m) // Error: will recur forever.
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
It's also easy to fix: convert the argument to the basic string type, which does not have the method.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type MyString string
func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", string(m)) // OK: note conversion.
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In the&nbsp;<a target="_blank" href="https://golang.org/doc/effective_go.html#initialization" style="color:rgb(55,94,171); text-decoration:none">initialization section</a>&nbsp;we'll see another technique that avoids this recursion.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Another printing technique is to pass a print routine's arguments directly to another such routine. The signature of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Printf</code>&nbsp;uses the type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">...interface{}</code>&nbsp;for
 its final argument to specify that an arbitrary number of parameters (of arbitrary type) can appear after the format.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func Printf(format string, v ...interface{}) (n int, err error) {
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Within the function&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Printf</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">v</code>&nbsp;acts like a variable of type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">[]interface{}</code>&nbsp;but
 if it is passed to another variadic function, it acts like a regular list of arguments. Here is the implementation of the function&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">log.Println</code>&nbsp;we used above. It passes its arguments directly
 to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">fmt.Sprintln</code>&nbsp;for the actual formatting.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Println prints to the standard logger in the manner of fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
We write&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">...</code>&nbsp;after&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">v</code>&nbsp;in the nested call to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sprintln</code>&nbsp;to tell the
 compiler to treat&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">v</code>&nbsp;as a list of arguments; otherwise it would just pass&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">v</code>&nbsp;as a single slice argument.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
There's even more to printing than we've covered here. See the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">godoc</code>&nbsp;documentation for package&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">fmt</code>&nbsp;for the details.</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-4512014793067058" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_7_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 837px; background-color: transparent;"><ins id="aswift_7_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 837px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="837" height="200" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_7" name="aswift_7" style="left:0;position:absolute;top:0;width:837px;height:200px;" src="./Effective Go - Go语言中文网 - Golang中文社区_files/saved_resource(4).html"></iframe></ins></ins></ins></div>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
By the way, a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">...</code>&nbsp;parameter can be of a specific type, for instance&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">...int</code>&nbsp;for a min function that chooses the least of a list
 of integers:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func Min(a ...int) int {
    min := int(^uint(0) &gt;&gt; 1)  // largest int
    for _, i := range a {
        if i &lt; min {
            min = i
        }
    }
    return min
}
</pre>
<h3 id="append" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Append</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Now we have the missing piece we needed to explain the design of the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">append</code>&nbsp;built-in function. The signature of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">append</code>&nbsp;is different
 from our custom&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Append</code>&nbsp;function above. Schematically, it's like this:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func append(slice []<em>T</em>, elements ...<em>T</em>) []<em>T</em>
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
where&nbsp;<em>T</em>&nbsp;is a placeholder for any given type. You can't actually write a function in Go where the type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">T</code>&nbsp;is determined by the caller. That's why&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">append</code>&nbsp;is
 built in: it needs support from the compiler.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
What&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">append</code>&nbsp;does is append the elements to the end of the slice and return the result. The result needs to be returned because, as with our hand-written&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Append</code>,
 the underlying array may change. This simple example</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
prints&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">[1 2 3 4 5 6]</code>. So&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">append</code>&nbsp;works a little like&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Printf</code>, collecting
 an arbitrary number of arguments.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
But what if we wanted to do what our&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Append</code>&nbsp;does and append a slice to a slice? Easy: use&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">...</code>&nbsp;at the call site, just as we did
 in the call to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Output</code>&nbsp;above. This snippet produces identical output to the one above.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Without that&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">...</code>, it wouldn't compile because the types would be wrong;&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">y</code>&nbsp;is not of type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">int</code>.</p>
<h2 id="initialization" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Initialization</h2>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Although it doesn't look superficially very different from initialization in C or C++, initialization in Go is more powerful. Complex structures can be built during initialization and the ordering issues among initialized objects, even among different packages,
 are handled correctly.</p>
<h3 id="constants" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Constants</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Constants in Go are just that—constant. They are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans. Because of the compile-time restriction, the expressions that define them must
 be constant expressions, evaluatable by the compiler. For instance,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">1&lt;&lt;3</code>&nbsp;is a constant expression, while&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">math.Sin(math.Pi/4)</code>&nbsp;is
 not because the function call to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">math.Sin</code>&nbsp;needs to happen at run time.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In Go, enumerated constants are created using the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">iota</code>&nbsp;enumerator. Since&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">iota</code>&nbsp;can be part of an expression and expressions can
 be implicitly repeated, it is easy to build intricate sets of values.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type ByteSize float64

const (
    _           = iota <span class="comment" style="color:rgb(0,102,0)">// ignore first value by assigning to blank identifier</span>
    KB ByteSize = 1 &lt;&lt; (10 * iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The ability to attach a method such as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">String</code>&nbsp;to any user-defined type makes it possible for arbitrary values to format themselves automatically for printing. Although you'll see it most often
 applied to structs, this technique is also useful for scalar types such as floating-point types like&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ByteSize</code>.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func (b ByteSize) String() string {
    switch {
    case b &gt;= YB:
        return fmt.Sprintf("%.2fYB", b/YB)
    case b &gt;= ZB:
        return fmt.Sprintf("%.2fZB", b/ZB)
    case b &gt;= EB:
        return fmt.Sprintf("%.2fEB", b/EB)
    case b &gt;= PB:
        return fmt.Sprintf("%.2fPB", b/PB)
    case b &gt;= TB:
        return fmt.Sprintf("%.2fTB", b/TB)
    case b &gt;= GB:
        return fmt.Sprintf("%.2fGB", b/GB)
    case b &gt;= MB:
        return fmt.Sprintf("%.2fMB", b/MB)
    case b &gt;= KB:
        return fmt.Sprintf("%.2fKB", b/KB)
    }
    return fmt.Sprintf("%.2fB", b)
}</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The expression&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">YB</code>&nbsp;prints as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">1.00YB</code>, while&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ByteSize(1e13)</code>&nbsp;prints
 as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">9.09TB</code>.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The use here of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sprintf</code>&nbsp;to implement&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ByteSize</code>'s&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">String</code>&nbsp;method
 is safe (avoids recurring indefinitely) not because of a conversion but because it calls&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sprintf</code>&nbsp;with&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">%f</code>, which is not a string
 format:&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sprintf</code>&nbsp;will only call the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">String</code>&nbsp;method when it wants a string, and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">%f</code>&nbsp;wants
 a floating-point value.</p>
<h3 id="variables" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Variables</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Variables can be initialized just like constants but the initializer can be a general expression computed at run time.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">var (
    home   = os.Getenv("HOME")
    user   = os.Getenv("USER")
    gopath = os.Getenv("GOPATH")
)
</pre>
<h3 id="init" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
The init function</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Finally, each source file can define its own niladic&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">init</code>&nbsp;function to set up whatever state is required. (Actually each file can have multiple&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">init</code>&nbsp;functions.)
 And finally means finally:&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">init</code>&nbsp;is called after all the variable declarations in the package have evaluated their initializers, and those are evaluated only after all the imported packages have
 been initialized.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Besides initializations that cannot be expressed as declarations, a common use of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">init</code>&nbsp;functions is to verify or repair correctness of the program state before real execution begins.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func init() {
    if user == "" {
        log.Fatal("$USER not set")
    }
    if home == "" {
        home = "/home/" + user
    }
    if gopath == "" {
        gopath = home + "/go"
    }
    // gopath may be overridden by --gopath flag on command line.
    flag.StringVar(&amp;gopath, "gopath", gopath, "override default GOPATH")
}
</pre>
<h2 id="methods" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Methods</h2>
<h3 id="pointers_vs_values" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Pointers vs. Values</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
As we saw with&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ByteSize</code>, methods can be defined for any named type (except a pointer or an interface); the receiver does not have to be a struct.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In the discussion of slices above, we wrote an&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Append</code>&nbsp;function. We can define it as a method on slices instead. To do this, we first declare a named type to which we can bind the method, and then
 make the receiver for the method a value of that type.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // Body exactly the same as above
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
This still requires the method to return the updated slice. We can eliminate that clumsiness by redefining the method to take a&nbsp;<em>pointer</em>&nbsp;to a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ByteSlice</code>&nbsp;as its receiver, so the method can
 overwrite the caller's slice.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // Body as above, without the return.
    *p = slice
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In fact, we can do even better. If we modify our function so it looks like a standard&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Write</code>&nbsp;method, like this,</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // Again as above.
    *p = slice
    return len(data), nil
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
then the type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">*ByteSlice</code>&nbsp;satisfies the standard interface&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.Writer</code>, which is handy. For instance, we can print into one.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">    var b ByteSlice
    fmt.Fprintf(&amp;b, "This hour has %d days\n", 7)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
We pass the address of a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ByteSlice</code>&nbsp;because only&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">*ByteSlice</code>&nbsp;satisfies&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.Writer</code>.
 The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
This rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception,
 though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">b</code>&nbsp;is
 addressable, so we can call its<code style="font-family:Menlo,monospace; font-size:14px">Write</code>&nbsp;method with just&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">b.Write</code>. The compiler will rewrite that to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">(&amp;b).Write</code>&nbsp;for
 us.</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-4512014793067058" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_8_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 837px; background-color: transparent;"><ins id="aswift_8_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 837px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="837" height="200" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_8" name="aswift_8" style="left:0;position:absolute;top:0;width:837px;height:200px;" src="./Effective Go - Go语言中文网 - Golang中文社区_files/saved_resource(5).html"></iframe></ins></ins></ins></div>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
By the way, the idea of using&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Write</code>&nbsp;on a slice of bytes is central to the implementation of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bytes.Buffer</code>.</p>
<h2 id="interfaces_and_types" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Interfaces and other types</h2>
<h3 id="interfaces" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Interfaces</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Interfaces in Go provide a way to specify the behavior of an object: if something can do&nbsp;<em>this</em>, then it can be used&nbsp;<em>here</em>. We've seen a couple of simple examples already; custom printers can be implemented by a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">String</code>&nbsp;method
 while&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Fprintf</code>&nbsp;can generate output to anything with a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Write</code>&nbsp;method. Interfaces with only one or two methods are common in Go code,
 and are usually given a name derived from the method, such as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.Writer</code>&nbsp;for something that implements&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Write</code>.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
A type can implement multiple interfaces. For instance, a collection can be sorted by the routines in package&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">sort</code>&nbsp;if it implements&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">sort.Interface</code>,
 which contains&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Len()</code>,<code style="font-family:Menlo,monospace; font-size:14px">Less(i, j int) bool</code>, and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Swap(i, j int)</code>,
 and it could also have a custom formatter. In this contrived example&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sequence</code>&nbsp;satisfies both.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type Sequence []int

<span class="comment" style="color:rgb(0,102,0)">// Methods required by sort.Interface.</span>
func (s Sequence) Len() int {
    return len(s)
}
func (s Sequence) Less(i, j int) bool {
    return s[i] &lt; s[j]
}
func (s Sequence) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}

<span class="comment" style="color:rgb(0,102,0)">// Method for printing - sorts the elements before printing.</span>
func (s Sequence) String() string {
    sort.Sort(s)
    str := "["
    for i, elem := range s {
        if i &gt; 0 {
            str += " "
        }
        str += fmt.Sprint(elem)
    }
    return str + "]"
}</pre>
<h3 id="conversions" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Conversions</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">String</code>&nbsp;method of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sequence</code>&nbsp;is recreating the work that&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sprint</code>&nbsp;already
 does for slices. We can share the effort if we convert the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sequence</code>&nbsp;to a plain&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">[]int</code>&nbsp;before calling<code style="font-family:Menlo,monospace; font-size:14px">Sprint</code>.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func (s Sequence) String() string {
    sort.Sort(s)
    return fmt.Sprint([]int(s))
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
This method is another example of the conversion technique for calling&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sprintf</code>&nbsp;safely from a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">String</code>&nbsp;method. Because the two types
 (<code style="font-family:Menlo,monospace; font-size:14px">Sequence</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">[]int</code>) are the same if we ignore the type name, it's legal to convert between them. The conversion doesn't create
 a new value, it just temporarily acts as though the existing value has a new type. (There are other legal conversions, such as from integer to floating point, that do create a new value.)</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
It's an idiom in Go programs to convert the type of an expression to access a different set of methods. As an example, we could use the existing type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">sort.IntSlice</code>&nbsp;to reduce the entire example
 to this:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type Sequence []int

// Method for printing - sorts the elements before printing
func (s Sequence) String() string {
    sort.IntSlice(s).Sort()
    return fmt.Sprint([]int(s))
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Now, instead of having&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sequence</code>&nbsp;implement multiple interfaces (sorting and printing), we're using the ability of a data item to be converted to multiple types (<code style="font-family:Menlo,monospace; font-size:14px">Sequence</code>,<code style="font-family:Menlo,monospace; font-size:14px">sort.IntSlice</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">[]int</code>),
 each of which does some part of the job. That's more unusual in practice but can be effective.</p>
<h3 id="interface_conversions" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Interface conversions and type assertions</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
<a target="_blank" href="https://golang.org/doc/effective_go.html#type_switch" style="color:rgb(55,94,171); text-decoration:none">Type switches</a>&nbsp;are a form of conversion: they take an interface and, for each case in the switch, in a sense convert it to the
 type of that case. Here's a simplified version of how the code under&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">fmt.Printf</code>&nbsp;turns a value into a string using a type switch. If it's already a string, we want the actual string value held
 by the interface, while if it has a<code style="font-family:Menlo,monospace; font-size:14px">String</code>&nbsp;method we want the result of calling the method.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type Stringer interface {
    String() string
}

var value interface{} // Value provided by caller.
switch str := value.(type) {
case string:
    return str
case Stringer:
    return str.String()
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The first case finds a concrete value; the second converts the interface into another interface. It's perfectly fine to mix types this way.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
What if there's only one type we care about? If we know the value holds a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">string</code>&nbsp;and we just want to extract it? A one-case type switch would do, but so would a&nbsp;<em>type assertion</em>. A type
 assertion takes an interface value and extracts from it a value of the specified explicit type. The syntax borrows from the clause opening a type switch, but with an explicit type rather than the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">type</code>&nbsp;keyword:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">value.(typeName)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
and the result is a new value with the static type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">typeName</code>. That type must either be the concrete type held by the interface, or a second interface type that the value can be converted to. To
 extract the string we know is in the value, we could write:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">str := value.(string)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
But if it turns out that the value does not contain a string, the program will crash with a run-time error. To guard against that, use the "comma, ok" idiom to test, safely, whether the value is a string:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">str, ok := value.(string)
if ok {
    fmt.Printf("string value is: %q\n", str)
} else {
    fmt.Printf("value is not a string\n")
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If the type assertion fails,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">str</code>&nbsp;will still exist and be of type string, but it will have the zero value, an empty string.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
As an illustration of the capability, here's an&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">if</code>-<code style="font-family:Menlo,monospace; font-size:14px">else</code>&nbsp;statement that's equivalent to the type switch that opened this section.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">if str, ok := value.(string); ok {
    return str
} else if str, ok := value.(Stringer); ok {
    return str.String()
}
</pre>
<h3 id="generality" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Generality</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If a type exists only to implement an interface and has no exported methods beyond that interface, there is no need to export the type itself. Exporting just the interface makes it clear that it's the behavior that matters, not the implementation, and that
 other implementations with different properties can mirror the behavior of the original type. It also avoids the need to repeat the documentation on every instance of a common method.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In such cases, the constructor should return an interface value rather than the implementing type. As an example, in the hash libraries both&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">crc32.NewIEEE</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">adler32.New</code>return
 the interface type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">hash.Hash32</code>. Substituting the CRC-32 algorithm for Adler-32 in a Go program requires only changing the constructor call; the rest of the code is unaffected by the change of
 algorithm.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
A similar approach allows the streaming cipher algorithms in the various&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">crypto</code>&nbsp;packages to be separated from the block ciphers they chain together. The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Block</code>&nbsp;interface
 in the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">crypto/cipher</code>&nbsp;package specifies the behavior of a block cipher, which provides encryption of a single block of data. Then, by analogy with the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bufio</code>&nbsp;package,
 cipher packages that implement this interface can be used to construct streaming ciphers, represented by the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Stream</code>&nbsp;interface, without knowing the details of the block encryption.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">crypto/cipher</code>&nbsp;interfaces look like this:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type Block interface {
    BlockSize() int
    Encrypt(src, dst []byte)
    Decrypt(src, dst []byte)
}

type Stream interface {
    XORKeyStream(dst, src []byte)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Here's the definition of the counter mode (CTR) stream, which turns a block cipher into a streaming cipher; notice that the block cipher's details are abstracted away:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// NewCTR returns a Stream that encrypts/decrypts using the given Block in
// counter mode. The length of iv must be the same as the Block's block size.
func NewCTR(block Block, iv []byte) Stream
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
<code style="font-family:Menlo,monospace; font-size:14px">NewCTR</code>&nbsp;applies not just to one specific encryption algorithm and data source but to any implementation of the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Block</code>&nbsp;interface and
 any&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Stream</code>. Because they return interface values, replacing CTR encryption with other encryption modes is a localized change. The constructor calls must be edited, but because the surrounding
 code must treat the result only as a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Stream</code>, it won't notice the difference.</p>
<h3 id="interface_methods" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Interfaces and methods</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Since almost anything can have methods attached, almost anything can satisfy an interface. One illustrative example is in the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">http</code>&nbsp;package, which defines the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Handler</code>interface.
 Any object that implements&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Handler</code>&nbsp;can serve HTTP requests.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
<code style="font-family:Menlo,monospace; font-size:14px">ResponseWriter</code>&nbsp;is itself an interface that provides access to the methods needed to return the response to the client. Those methods include the standard&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Write</code>&nbsp;method,
 so an&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">http.ResponseWriter</code>&nbsp;can be used wherever an&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.Writer</code>&nbsp;can be used.&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Request</code>&nbsp;is
 a struct containing a parsed representation of the request from the client.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
For brevity, let's ignore POSTs and assume HTTP requests are always GETs; that simplification does not affect the way the handlers are set up. Here's a trivial but complete implementation of a handler to count the number of times the page is visited.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Simple counter server.
type Counter struct {
    n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ctr.n++
    fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
(Keeping with our theme, note how&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Fprintf</code>&nbsp;can print to an&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">http.ResponseWriter</code>.) For reference, here's how to attach such a server
 to a node on the URL tree.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">import "net/http"
...
ctr := new(Counter)
http.Handle("/counter", ctr)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
But why make&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Counter</code>&nbsp;a struct? An integer is all that's needed. (The receiver needs to be a pointer so the increment is visible to the caller.)</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Simpler counter server.
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    *ctr++
    fmt.Fprintf(w, "counter = %d\n", *ctr)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
What if your program has some internal state that needs to be notified that a page has been visited? Tie a channel to the web page.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// A channel that sends a notification on each visit.
// (Probably want the channel to be buffered.)
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ch &lt;- req
    fmt.Fprint(w, "notification sent")
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Finally, let's say we wanted to present on&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">/args</code>&nbsp;the arguments used when invoking the server binary. It's easy to write a function to print the arguments.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func ArgServer() {
    fmt.Println(os.Args)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
How do we turn that into an HTTP server? We could make&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ArgServer</code>&nbsp;a method of some type whose value we ignore, but there's a cleaner way. Since we can define a method for any type except pointers
 and interfaces, we can write a method for a function. The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">http</code>&nbsp;package contains this code:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers.  If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler object that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(c, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
    f(w, req)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
<code style="font-family:Menlo,monospace; font-size:14px">HandlerFunc</code>&nbsp;is a type with a method,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ServeHTTP</code>, so values of that type can serve HTTP requests. Look at the implementation of the
 method: the receiver is a function,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">f</code>, and the method calls&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">f</code>. That may seem odd but it's not that different from, say, the receiver
 being a channel and the method sending on the channel.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
To make&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ArgServer</code>&nbsp;into an HTTP server, we first modify it to have the right signature.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Argument server.
func ArgServer(w http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(w, os.Args)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
<code style="font-family:Menlo,monospace; font-size:14px">ArgServer</code>&nbsp;now has same signature as&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">HandlerFunc</code>, so it can be converted to that type to access its methods, just as we converted&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Sequence</code>&nbsp;to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">IntSlice</code>&nbsp;to
 access<code style="font-family:Menlo,monospace; font-size:14px">IntSlice.Sort</code>. The code to set it up is concise:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">http.Handle("/args", http.HandlerFunc(ArgServer))
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
When someone visits the page&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">/args</code>, the handler installed at that page has value&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ArgServer</code>&nbsp;and type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">HandlerFunc</code>.
 The HTTP server will invoke the method&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ServeHTTP</code>&nbsp;of that type, with&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ArgServer</code>&nbsp;as the receiver, which will in turn call&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ArgServer</code>&nbsp;(via
 the invocation&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">f(c, req)</code>&nbsp;inside&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">HandlerFunc.ServeHTTP</code>). The arguments will then be displayed.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In this section we have made an HTTP server from a struct, an integer, a channel, and a function, all because interfaces are just sets of methods, which can be defined for (almost) any type.</p>
<h2 id="blank" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
The blank identifier</h2>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
We've mentioned the blank identifier a couple of times now, in the context of&nbsp;<a target="_blank" href="https://golang.org/doc/effective_go.html#for" style="color:rgb(55,94,171); text-decoration:none"><code style="font-family:Menlo,monospace; font-size:14px">for</code>&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">range</code>&nbsp;loops</a>&nbsp;and&nbsp;<a target="_blank" href="https://golang.org/doc/effective_go.html#maps" style="color:rgb(55,94,171); text-decoration:none">maps</a>.
 The blank identifier can be assigned or declared with any value of any type, with the value discarded harmlessly. It's a bit like writing to the Unix&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">/dev/null</code>&nbsp;file: it represents a write-only
 value to be used as a place-holder where a variable is needed but the actual value is irrelevant. It has uses beyond those we've seen already.</p>
<h3 id="blank_assign" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
The blank identifier in multiple assignment</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The use of a blank identifier in a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">for</code>&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">range</code>&nbsp;loop is a special case of a general situation: multiple assignment.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If an assignment requires multiple values on the left side, but one of the values will not be used by the program, a blank identifier on the left-hand-side of the assignment avoids the need to create a dummy variable and makes it clear that the value is to
 be discarded. For instance, when calling a function that returns a value and an error, but only the error is important, use the blank identifier to discard the irrelevant value.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">if _, err := os.Stat(path); os.IsNotExist(err) {
	fmt.Printf("%s does not exist\n", path)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Occasionally you'll see code that discards the error value in order to ignore the error; this is terrible practice. Always check error returns; they're provided for a reason.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Bad! This code will crash if path does not exist.
fi, _ := os.Stat(path)
if fi.IsDir() {
    fmt.Printf("%s is a directory\n", path)
}
</pre>
<h3 id="blank_unused" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Unused imports and variables</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
It is an error to import a package or to declare a variable without using it. Unused imports bloat the program and slow compilation, while a variable that is initialized but not used is at least a wasted computation and perhaps indicative of a larger bug. When
 a program is under active development, however, unused imports and variables often arise and it can be annoying to delete them just to have the compilation proceed, only to have them be needed again later. The blank identifier provides a workaround.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
This half-written program has two unused imports (<code style="font-family:Menlo,monospace; font-size:14px">fmt</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io</code>) and an unused variable (<code style="font-family:Menlo,monospace; font-size:14px">fd</code>),
 so it will not compile, but it would be nice to see if the code so far is correct.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    <span class="comment" style="color:rgb(0,102,0)">// TODO: use fd.</span>
}</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
To silence complaints about the unused imports, use a blank identifier to refer to a symbol from the imported package. Similarly, assigning the unused variable&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">fd</code>&nbsp;to the blank identifier will
 silence the unused variable error. This version of the program does compile.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

var _ = fmt.Printf <span class="comment" style="color:rgb(0,102,0)">// For debugging; delete when done.</span>
var _ io.Reader    <span class="comment" style="color:rgb(0,102,0)">// For debugging; delete when done.</span>

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    <span class="comment" style="color:rgb(0,102,0)">// TODO: use fd.</span>
    _ = fd
}</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
By convention, the global declarations to silence import errors should come right after the imports and be commented, both to make them easy to find and as a reminder to clean things up later.</p>
<h3 id="blank_import" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Import for side effect</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
An unused import like&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">fmt</code>&nbsp;or&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io</code>&nbsp;in the previous example should eventually be used or removed: blank assignments identify code as
 a work in progress. But sometimes it is useful to import a package only for its side effects, without any explicit use. For example, during its&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">init</code>&nbsp;function, the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px"><a target="_blank" href="https://golang.org/pkg/net/http/pprof/" style="color:rgb(55,94,171); text-decoration:none">net/http/pprof</a></code>&nbsp;package
 registers HTTP handlers that provide debugging information. It has an exported API, but most clients need only the handler registration and access the data through a web page. To import the package only for its side effects, rename the package to the blank
 identifier:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">import _ "net/http/pprof"
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
This form of import makes clear that the package is being imported for its side effects, because there is no other possible use of the package: in this file, it doesn't have a name. (If it did, and we didn't use that name, the compiler would reject the program.)</p>
<h3 id="blank_implements" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Interface checks</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
As we saw in the discussion of&nbsp;<a target="_blank" href="https://golang.org/doc/effective_go.html#interfaces_and_types" style="color:rgb(55,94,171); text-decoration:none">interfaces</a>&nbsp;above, a type need not declare explicitly that it implements an interface.
 Instead, a type implements the interface just by implementing the interface's methods. In practice, most interface conversions are static and therefore checked at compile time. For example, passing an&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">*os.File</code>&nbsp;to
 a function expecting an&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.Reader</code>&nbsp;will not compile unless&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">*os.File</code>&nbsp;implements the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.Reader</code>&nbsp;interface.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Some interface checks do happen at run-time, though. One instance is in the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px"><a target="_blank" href="https://golang.org/pkg/encoding/json/" style="color:rgb(55,94,171); text-decoration:none">encoding/json</a></code>&nbsp;package,
 which defines a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px"><a target="_blank" href="https://golang.org/pkg/encoding/json/#Marshaler" style="color:rgb(55,94,171); text-decoration:none">Marshaler</a></code>&nbsp;interface. When the JSON encoder receives
 a value that implements that interface, the encoder invokes the value's marshaling method to convert it to JSON instead of doing the standard conversion. The encoder checks this property at run time with a&nbsp;<a target="_blank" href="https://golang.org/doc/effective_go.html#interface_conversions" style="color:rgb(55,94,171); text-decoration:none">type
 assertion</a>&nbsp;like:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">m, ok := val.(json.Marshaler)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If it's necessary only to ask whether a type implements an interface, without actually using the interface itself, perhaps as part of an error check, use the blank identifier to ignore the type-asserted value:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">if _, ok := val.(json.Marshaler); ok {
    fmt.Printf("value %v of type %T implements json.Marshaler\n", val, val)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
One place this situation arises is when it is necessary to guarantee within the package implementing the type that it actually satisfies the interface. If a type—for example,<code style="font-family:Menlo,monospace; font-size:14px"><a target="_blank" href="https://golang.org/pkg/encoding/json/#RawMessage" style="color:rgb(55,94,171); text-decoration:none">json.RawMessage</a></code>—needs
 a custom JSON representation, it should implement&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">json.Marshaler</code>, but there are no static conversions that would cause the compiler to verify this automatically. If the type inadvertently fails
 to satisfy the interface, the JSON encoder will still work, but will not use the custom implementation. To guarantee that the implementation is correct, a global declaration using the blank identifier can be used in the package:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">var _ json.Marshaler = (*RawMessage)(nil)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In this declaration, the assignment involving a conversion of a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">*RawMessage</code>&nbsp;to a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Marshaler</code>&nbsp;requires that&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">*RawMessage</code>&nbsp;implements&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Marshaler</code>,
 and that property will be checked at compile time. Should the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">json.Marshaler</code>&nbsp;interface change, this package will no longer compile and we will be on notice that it needs to be updated.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The appearance of the blank identifier in this construct indicates that the declaration exists only for the type checking, not to create a variable. Don't do this for every type that satisfies an interface, though. By convention, such declarations are only
 used when there are no static conversions already present in the code, which is a rare event.</p>
<h2 id="embedding" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Embedding</h2>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Go does not provide the typical, type-driven notion of subclassing, but it does have the ability to “borrow” pieces of an implementation by&nbsp;<em>embedding</em>&nbsp;types within a struct or interface.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Interface embedding is very simple. We've mentioned the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.Reader</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.Writer</code>&nbsp;interfaces before; here are their definitions.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io</code>&nbsp;package also exports several other interfaces that specify objects that can implement several such methods. For instance, there is&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.ReadWriter</code>,
 an interface containing both&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Read</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Write</code>. We could specify&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.ReadWriter</code>&nbsp;by
 listing the two methods explicitly, but it's easier and more evocative to embed the two interfaces to form the new one, like this:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// ReadWriter is the interface that combines the Reader and Writer interfaces.
type ReadWriter interface {
    Reader
    Writer
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
This says just what it looks like: A&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ReadWriter</code>&nbsp;can do what a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Reader</code>&nbsp;does&nbsp;<em>and</em>&nbsp;what a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Writer</code>&nbsp;does;
 it is a union of the embedded interfaces (which must be disjoint sets of methods). Only interfaces can be embedded within interfaces.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The same basic idea applies to structs, but with more far-reaching implications. The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bufio</code>&nbsp;package has two struct types,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bufio.Reader</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bufio.Writer</code>,
 each of which of course implements the analogous interfaces from package&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io</code>. And&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bufio</code>&nbsp;also implements a buffered reader/writer,
 which it does by combining a reader and a writer into one struct using embedding: it lists the types within the struct but does not give them field names.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// ReadWriter stores pointers to a Reader and a Writer.
// It implements io.ReadWriter.
type ReadWriter struct {
    *Reader  // *bufio.Reader
    *Writer  // *bufio.Writer
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The embedded elements are pointers to structs and of course must be initialized to point to valid structs before they can be used. The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ReadWriter</code>&nbsp;struct could be written as</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type ReadWriter struct {
    reader *Reader
    writer *Writer
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
but then to promote the methods of the fields and to satisfy the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io</code>&nbsp;interfaces, we would also need to provide forwarding methods, like this:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func (rw *ReadWriter) Read(p []byte) (n int, err error) {
    return rw.reader.Read(p)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
By embedding the structs directly, we avoid this bookkeeping. The methods of embedded types come along for free, which means that&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bufio.ReadWriter</code>&nbsp;not only has the methods of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bufio.Reader</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bufio.Writer</code>,
 it also satisfies all three interfaces:&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.Reader</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.Writer</code>, and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">io.ReadWriter</code>.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
There's an important way in which embedding differs from subclassing. When we embed a type, the methods of that type become methods of the outer type, but when they are invoked the receiver of the method is the inner type, not the outer one. In our example,
 when the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Read</code>&nbsp;method of a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">bufio.ReadWriter</code>&nbsp;is invoked, it has exactly the same effect as the forwarding method written out above;
 the receiver is the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">reader</code>&nbsp;field of the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ReadWriter</code>, not the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ReadWriter</code>&nbsp;itself.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Embedding can also be a simple convenience. This example shows an embedded field alongside a regular, named field.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type Job struct {
    Command string
    *log.Logger
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Job</code>&nbsp;type now has the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Log</code>,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Logf</code>&nbsp;and other methods of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">*log.Logger</code>.
 We could have given the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Logger</code>&nbsp;a field name, of course, but it's not necessary to do so. And now, once initialized, we can log to the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Job</code>:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">job.Log("starting now...")
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Logger</code>&nbsp;is a regular field of the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Job</code>&nbsp;struct, so we can initialize it in the usual way inside the constructor for&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Job</code>,
 like this,</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func NewJob(command string, logger *log.Logger) *Job {
    return &amp;Job{command, logger}
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
or with a composite literal,</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">job := &amp;Job{command, log.New(os.Stderr, "Job: ", log.Ldate)}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If we need to refer to an embedded field directly, the type name of the field, ignoring the package qualifier, serves as a field name, as it did in the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Read</code>&nbsp;method of our<code style="font-family:Menlo,monospace; font-size:14px">ReaderWriter</code>&nbsp;struct.
 Here, if we needed to access the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">*log.Logger</code>&nbsp;of a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Job</code>&nbsp;variable&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">job</code>,
 we would write&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">job.Logger</code>, which would be useful if we wanted to refine the methods of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Logger</code>.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func (job *Job) Logf(format string, args ...interface{}) {
    job.Logger.Logf("%q: %s", job.Command, fmt.Sprintf(format, args...))
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Embedding types introduces the problem of name conflicts but the rules to resolve them are simple. First, a field or method&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">X</code>&nbsp;hides any other item&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">X</code>&nbsp;in
 a more deeply nested part of the type. If&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">log.Logger</code>&nbsp;contained a field or method called&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Command</code>, the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Command</code>&nbsp;field
 of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Job</code>&nbsp;would dominate it.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Second, if the same name appears at the same nesting level, it is usually an error; it would be erroneous to embed&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">log.Logger</code>&nbsp;if the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Job</code>&nbsp;struct
 contained another field or method called&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Logger</code>. However, if the duplicate name is never mentioned in the program outside the type definition, it is OK. This qualification provides some protection
 against changes made to types embedded from outside; there is no problem if a field is added that conflicts with another field in another subtype if neither field is ever used.</p>
<h2 id="concurrency" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Concurrency</h2>
<h3 id="sharing" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Share by communicating</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Concurrent programming is a large topic and there is space only for some Go-specific highlights here.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Concurrent programming in many environments is made difficult by the subtleties required to implement correct access to shared variables. Go encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared
 by separate threads of execution. Only one goroutine has access to the value at any given time. Data races cannot occur, by design. To encourage this way of thinking we have reduced it to a slogan:</p>
<blockquote style="color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Do not communicate by sharing memory; instead, share memory by communicating.</blockquote>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
This approach can be taken too far. Reference counts may be best done by putting a mutex around an integer variable, for instance. But as a high-level approach, using channels to control access makes it easier to write clear, correct programs.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
One way to think about this model is to consider a typical single-threaded program running on one CPU. It has no need for synchronization primitives. Now run another such instance; it too needs no synchronization. Now let those two communicate; if the communication
 is the synchronizer, there's still no need for other synchronization. Unix pipelines, for example, fit this model perfectly. Although Go's approach to concurrency originates in Hoare's Communicating Sequential Processes (CSP), it can also be seen as a type-safe
 generalization of Unix pipes.</p>
<h3 id="goroutines" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Goroutines</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
They're called&nbsp;<em>goroutines</em>&nbsp;because the existing terms—threads, coroutines, processes, and so on—convey inaccurate connotations. A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space.
 It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Goroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I/O, others continue to run. Their design hides many of the complexities of thread creation and management.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Prefix a function or method call with the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">go</code>&nbsp;keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently. (The effect is similar to the Unix shell's&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">&amp;</code>&nbsp;notation
 for running a command in the background.)</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">go list.Sort()  // run list.Sort concurrently; don't wait for it.
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
A function literal can be handy in a goroutine invocation.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func Announce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()  // Note the parentheses - must call the function.
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In Go, function literals are closures: the implementation makes sure the variables referred to by the function survive as long as they are active.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
These examples aren't too practical because the functions have no way of signaling completion. For that, we need channels.</p>
<h3 id="channels" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Channels</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Like maps, channels are allocated with&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">make</code>, and the resulting value acts as a reference to an underlying data structure. If an optional integer parameter is provided, it sets the buffer size
 for the channel. The default is zero, for an unbuffered or synchronous channel.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">ci := make(chan int)            // unbuffered channel of integers
cj := make(chan int, 0)         // unbuffered channel of integers
cs := make(chan *os.File, 100)  // buffered channel of pointers to Files
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Unbuffered channels combine communication—the exchange of a value—with synchronization—guaranteeing that two calculations (goroutines) are in a known state.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
There are lots of nice idioms using channels. Here's one to get us started. In the previous section we launched a sort in the background. A channel can allow the launching goroutine to wait for the sort to complete.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">c := make(chan int)  // Allocate a channel.
// Start the sort in a goroutine; when it completes, signal on the channel.
go func() {
    list.Sort()
    c &lt;- 1  // Send a signal; value does not matter.
}()
doSomethingForAWhile()
&lt;-c   // Wait for sort to finish; discard sent value.
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Receivers always block until there is data to receive. If the channel is unbuffered, the sender blocks until the receiver has received the value. If the channel has a buffer, the sender blocks only until the value has been copied to the buffer; if the buffer
 is full, this means waiting until some receiver has retrieved a value.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
A buffered channel can be used like a semaphore, for instance to limit throughput. In this example, incoming requests are passed to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">handle</code>, which sends a value into the channel, processes the
 request, and then receives a value from the channel to ready the “semaphore” for the next consumer. The capacity of the channel buffer limits the number of simultaneous calls to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">process</code>.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem &lt;- 1    // Wait for active queue to drain.
    process(r)  // May take a long time.
    &lt;-sem       // Done; enable next request to run.
}

func Serve(queue chan *Request) {
    for {
        req := &lt;-queue
        go handle(req)  // Don't wait for handle to finish.
    }
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Once&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">MaxOutstanding</code>&nbsp;handlers are executing&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">process</code>, any more will block trying to send into the filled channel buffer, until one
 of the existing handlers finishes and receives from the buffer.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
This design has a problem, though:&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Serve</code>&nbsp;creates a new goroutine for every incoming request, even though only&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">MaxOutstanding</code>&nbsp;of
 them can run at any moment. As a result, the program can consume unlimited resources if the requests come in too fast. We can address that deficiency by changing&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Serve</code>&nbsp;to gate the creation of
 the goroutines. Here's an obvious solution, but beware it has a bug we'll fix subsequently:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func Serve(queue chan *Request) {
    for req := range queue {
        sem &lt;- 1
        go func() {
            process(req) // Buggy; see explanation below.
            &lt;-sem
        }()
    }
}</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The bug is that in a Go&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">for</code>&nbsp;loop, the loop variable is reused for each iteration, so the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">req</code>&nbsp;variable is shared across all goroutines.
 That's not what we want. We need to make sure that&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">req</code>&nbsp;is unique for each goroutine. Here's one way to do that, passing the value of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">req</code>&nbsp;as
 an argument to the closure in the goroutine:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func Serve(queue chan *Request) {
    for req := range queue {
        sem &lt;- 1
        go func(req *Request) {
            process(req)
            &lt;-sem
        }(req)
    }
}</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Compare this version with the previous to see the difference in how the closure is declared and run. Another solution is just to create a new variable with the same name, as in this example:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func Serve(queue chan *Request) {
    for req := range queue {
        req := req // Create new instance of req for the goroutine.
        sem &lt;- 1
        go func() {
            process(req)
            &lt;-sem
        }()
    }
}</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
It may seem odd to write</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">req := req
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
but it's a legal and idiomatic in Go to do this. You get a fresh version of the variable with the same name, deliberately shadowing the loop variable locally but unique to each goroutine.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Going back to the general problem of writing the server, another approach that manages resources well is to start a fixed number of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">handle</code>&nbsp;goroutines all reading from the request channel. The
 number of goroutines limits the number of simultaneous calls to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">process</code>. This&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Serve</code>&nbsp;function also accepts a channel on which it
 will be told to exit; after launching the goroutines it blocks receiving from that channel.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func handle(queue chan *Request) {
    for r := range queue {
        process(r)
    }
}

func Serve(clientRequests chan *Request, quit chan bool) {
    // Start handlers
    for i := 0; i &lt; MaxOutstanding; i++ {
        go handle(clientRequests)
    }
    &lt;-quit  // Wait to be told to exit.
}
</pre>
<h3 id="chan_of_chan" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Channels of channels</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
One of the most important properties of Go is that a channel is a first-class value that can be allocated and passed around like any other. A common use of this property is to implement safe, parallel demultiplexing.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In the example in the previous section,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">handle</code>&nbsp;was an idealized handler for a request but we didn't define the type it was handling. If that type includes a channel on which to reply, each client
 can provide its own path for the answer. Here's a schematic definition of type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Request</code>.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The client provides a function and its arguments, as well as a channel inside the request object on which to receive the answer.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &amp;Request{[]int{3, 4, 5}, sum, make(chan int)}
// Send request
clientRequests &lt;- request
// Wait for response.
fmt.Printf("answer: %d\n", &lt;-request.resultChan)
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
On the server side, the handler function is the only thing that changes.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan &lt;- req.f(req.args)
    }
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
There's clearly a lot more to do to make it realistic, but this code is a framework for a rate-limited, parallel, non-blocking RPC system, and there's not a mutex in sight.</p>
<h3 id="parallel" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Parallelization</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Another application of these ideas is to parallelize a calculation across multiple CPU cores. If the calculation can be broken into separate pieces that can execute independently, it can be parallelized, with a channel to signal when each piece completes.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Let's say we have an expensive operation to perform on a vector of items, and that the value of the operation on each item is independent, as in this idealized example.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type Vector []float64

// Apply the operation to v[i], v[i+1] ... up to v[n-1].
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i &lt; n; i++ {
        v[i] += u.Op(v[i])
    }
    c &lt;- 1    // signal that this piece is done
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
We launch the pieces independently in a loop, one per CPU. They can complete in any order but it doesn't matter; we just count the completion signals by draining the channel after launching all the goroutines.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">const NCPU = 4  // number of CPU cores

func (v Vector) DoAll(u Vector) {
    c := make(chan int, NCPU)  // Buffering optional but sensible.
    for i := 0; i &lt; NCPU; i++ {
        go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c)
    }
    // Drain the channel.
    for i := 0; i &lt; NCPU; i++ {
        &lt;-c    // wait for one task to complete
    }
    // All done.
}

</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The current implementation of the Go runtime will not parallelize this code by default. It dedicates only a single core to user-level processing. An arbitrary number of goroutines can be blocked in system calls, but by default only one can be executing user-level
 code at any time. It should be smarter and one day it will be smarter, but until it is if you want CPU parallelism you must tell the run-time how many goroutines you want executing code simultaneously. There are two related ways to do this. Either run your
 job with environment variable&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">GOMAXPROCS</code>&nbsp;set to the number of cores to use or import the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">runtime</code>&nbsp;package and call&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">runtime.GOMAXPROCS(NCPU)</code>.
 A helpful value might be&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">runtime.NumCPU()</code>, which reports the number of logical CPUs on the local machine. Again, this requirement is expected to be retired as the scheduling and run-time improve.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Be sure not to confuse the ideas of concurrency—structuring a program as independently executing components—and parallelism—executing calculations in parallel for efficiency on multiple CPUs. Although the concurrency features of Go can make some problems easy
 to structure as parallel computations, Go is a concurrent language, not a parallel one, and not all parallelization problems fit Go's model. For a discussion of the distinction, see the talk cited in&nbsp;<a target="_blank" href="https://blog.golang.org/2013/01/concurrency-is-not-parallelism.html" style="color:rgb(55,94,171); text-decoration:none">this
 blog post</a>.</p>
<h3 id="leaky_buffer" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
A leaky buffer</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The tools of concurrent programming can even make non-concurrent ideas easier to express. Here's an example abstracted from an RPC package. The client goroutine loops receiving data from some source, perhaps a network. To avoid allocating and freeing buffers,
 it keeps a free list, and uses a buffered channel to represent it. If the channel is empty, a new buffer gets allocated. Once the message buffer is ready, it's sent to the server on&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">serverChan</code>.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
    for {
        var b *Buffer
        // Grab a buffer if available; allocate if not.
        select {
        case b = &lt;-freeList:
            // Got one; nothing more to do.
        default:
            // None free, so allocate a new one.
            b = new(Buffer)
        }
        load(b)              // Read next message from the net.
        serverChan &lt;- b      // Send to server.
    }
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The server loop receives each message from the client, processes it, and returns the buffer to the free list.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func server() {
    for {
        b := &lt;-serverChan    // Wait for work.
        process(b)
        // Reuse buffer if there's room.
        select {
        case freeList &lt;- b:
            // Buffer on free list; nothing more to do.
        default:
            // Free list full, just carry on.
        }
    }
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The client attempts to retrieve a buffer from&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">freeList</code>; if none is available, it allocates a fresh one. The server's send to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">freeList</code>&nbsp;puts&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">b</code>&nbsp;back
 on the free list unless the list is full, in which case the buffer is dropped on the floor to be reclaimed by the garbage collector. (The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">default</code>&nbsp;clauses in the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">select</code>&nbsp;statements
 execute when no other case is ready, meaning that the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">selects</code>&nbsp;never block.) This implementation builds a leaky bucket free list in just a few lines, relying on the buffered channel and the garbage
 collector for bookkeeping.</p>
<h2 id="errors" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
Errors</h2>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Library routines must often return some sort of error indication to the caller. As mentioned earlier, Go's multivalue return makes it easy to return a detailed error description alongside the normal return value. It is good style to use this feature to provide
 detailed error information. For example, as we'll see,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">os.Open</code>&nbsp;doesn't just return a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">nil</code>pointer on failure, it also returns an
 error value that describes what went wrong.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
By convention, errors have type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">error</code>, a simple built-in interface.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">type error interface {
    Error() string
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
A library writer is free to implement this interface with a richer model under the covers, making it possible not only to see the error but also to provide some context. As mentioned, alongside the usual&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">*os.File</code>&nbsp;return
 value,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">os.Open</code>&nbsp;also returns an error value. If the file is opened successfully, the error will be&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">nil</code>, but when there is a problem,
 it will hold an&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">os.PathError</code>:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// PathError records an error and the operation and
// file path that caused it.
type PathError struct {
    Op string    // "open", "unlink", etc.
    Path string  // The associated file.
    Err error    // Returned by the system call.
}

func (e *PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
<code style="font-family:Menlo,monospace; font-size:14px">PathError</code>'s&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Error</code>&nbsp;generates a string like this:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">open /etc/passwx: no such file or directory
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Such an error, which includes the problematic file name, the operation, and the operating system error it triggered, is useful even if printed far from the call that caused it; it is much more informative than the plain "no such file or directory".</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
When feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error. For example, in package<code style="font-family:Menlo,monospace; font-size:14px">image</code>, the string representation
 for a decoding error due to an unknown format is "image: unknown format".</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Callers that care about the precise error details can use a type switch or a type assertion to look for specific errors and extract details. For&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">PathErrors</code>&nbsp;this might include examining the internal&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Err</code>&nbsp;field
 for recoverable failures.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">for try := 0; try &lt; 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
    if e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The second&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">if</code>&nbsp;statement here is another&nbsp;<a target="_blank" href="https://golang.org/doc/effective_go.html#interface_conversions" style="color:rgb(55,94,171); text-decoration:none">type assertion</a>.
 If it fails,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ok</code>&nbsp;will be false, and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">e</code>&nbsp;will be&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">nil</code>. If it succeeds,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">ok</code>&nbsp;will
 be true, which means the error was of type<code style="font-family:Menlo,monospace; font-size:14px">*os.PathError</code>, and then so is&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">e</code>, which we can examine for more information about the
 error.</p>
<h3 id="panic" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Panic</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The usual way to report an error to a caller is to return an&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">error</code>&nbsp;as an extra return value. The canonical&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Read</code>&nbsp;method is a well-known
 instance; it returns a byte count and an&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">error</code>. But what if the error is unrecoverable? Sometimes the program simply cannot continue.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
For this purpose, there is a built-in function&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">panic</code>&nbsp;that in effect creates a run-time error that will stop the program (but see the next section). The function takes a single argument of arbitrary
 type—often a string—to be printed as the program dies. It's also a way to indicate that something impossible has happened, such as exiting an infinite loop.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
    z := x/3   // Arbitrary initial value
    for i := 0; i &lt; 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // A million iterations has not converged; something is wrong.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
This is only an example but real library functions should avoid&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">panic</code>. If the problem can be masked or worked around, it's always better to let things continue to run rather than taking down the
 whole program. One possible counterexample is during initialization: if the library truly cannot set itself up, it might be reasonable to panic, so to speak.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}
</pre>
<h3 id="recover" style="margin:20px 5px; padding:0px; color:rgb(55,94,171); font-size:20px; font-family:Helvetica,Arial,sans-serif">
Recover</h3>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
When&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">panic</code>&nbsp;is called, including implicitly for run-time errors such as indexing a slice out of bounds or failing a type assertion, it immediately stops execution of the current function and begins
 unwinding the stack of the goroutine, running any deferred functions along the way. If that unwinding reaches the top of the goroutine's stack, the program dies. However, it is possible to use the built-in function&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">recover</code>&nbsp;to
 regain control of the goroutine and resume normal execution.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
A call to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">recover</code>&nbsp;stops the unwinding and returns the argument passed to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">panic</code>. Because the only code that runs while unwinding
 is inside deferred functions,&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">recover</code>&nbsp;is only useful inside deferred functions.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
One application of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">recover</code>&nbsp;is to shut down a failing goroutine inside a server without killing the other executing goroutines.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">func server(workChan &lt;-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
In this example, if&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">do(work)</code>&nbsp;panics, the result will be logged and the goroutine will exit cleanly without disturbing the others. There's no need to do anything else in the deferred closure; calling&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">recover</code>&nbsp;handles
 the condition completely.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Because&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">recover</code>&nbsp;always returns&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">nil</code>&nbsp;unless called directly from a deferred function, deferred code can call library routines that
 themselves use&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">panic</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">recover</code>&nbsp;without failing. As an example, the deferred function in&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">safelyDo</code>&nbsp;might
 call a logging function before calling&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">recover</code>, and that logging code would run unaffected by the panicking state.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
With our recovery pattern in place, the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">do</code>&nbsp;function (and anything it calls) can get out of any bad situation cleanly by calling&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">panic</code>.
 We can use that idea to simplify error handling in complex software. Let's look at an idealized version of a&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">regexp</code>&nbsp;package, which reports parsing errors by calling&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">panic</code>&nbsp;with
 a local error type. Here's the definition of&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Error</code>, an&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">error</code>&nbsp;method, and the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Compile</code>&nbsp;function.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
If&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">doParse</code>&nbsp;panics, the recovery block will set the return value to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">nil</code>—deferred functions can modify named return values. It will
 then check, in the assignment to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">err</code>, that the problem was a parse error by asserting that it has the local type&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Error</code>. If it
 does not, the type assertion will fail, causing a run-time error that continues the stack unwinding as though nothing had interrupted it. This check means that if something unexpected happens, such as an index out of bounds, the code will fail even though
 we are using<code style="font-family:Menlo,monospace; font-size:14px">panic</code>&nbsp;and&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">recover</code>&nbsp;to handle parse errors.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
With error handling in place, the&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">error</code>&nbsp;method (because it's a method bound to a type, it's fine, even natural, for it to have the same name as the builtin&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">error</code>&nbsp;type)
 makes it easy to report parse errors without worrying about unwinding the parse stack by hand:</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">if pos == 0 {
    re.error("'*' illegal at start of expression")
}
</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Useful though this pattern is, it should be used only within a package.&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">Parse</code>&nbsp;turns its internal&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">panic</code>&nbsp;calls into&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">error</code>&nbsp;values;
 it does not expose&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">panics</code>&nbsp;to its client. That is a good rule to follow.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
By the way, this re-panic idiom changes the panic value if an actual error occurs. However, both the original and new failures will be presented in the crash report, so the root cause of the problem will still be visible. Thus this simple re-panic approach
 is usually sufficient—it's a crash after all—but if you want to display only the original value, you can write a little more code to filter unexpected problems and re-panic with the original error. That's left as an exercise for the reader.</p>
<h2 id="web_server" style="margin:20px 0px; padding:2px 5px; color:rgb(55,94,171); font-size:20px; clear:right; font-family:Helvetica,Arial,sans-serif; background:rgb(224,235,245)">
A web server</h2>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Let's finish with a complete Go program, a web server. This one is actually a kind of web re-server. Google provides a service at&nbsp;<a target="_blank" href="http://chart.apis.google.com/" style="color:rgb(55,94,171); text-decoration:none">http://chart.apis.google.com</a>&nbsp;that
 does automatic formatting of data into charts and graphs. It's hard to use interactively, though, because you need to put the data into the URL as a query. The program here provides a nicer interface to one form of data: given a short piece of text, it calls
 on the chart server to produce a QR code, a matrix of boxes that encode the text. That image can be grabbed with your cell phone's camera and interpreted as, for instance, a URL, saving you typing the URL into the phone's tiny keyboard.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
Here's the complete program. An explanation follows.</p>
<pre style="font-family:Menlo,monospace; font-size:14px; line-height:18px; margin:20px; padding:10px; color:rgb(34,34,34); background:rgb(233,233,233)">package main

import (
    "flag"
    "html/template"
    "log"
    "net/http"
)

var addr = flag.String("addr", ":1718", "http service address") <span class="comment" style="color:rgb(0,102,0)">// Q=17, R=18</span>

var templ = template.Must(template.New("qr").Parse(templateStr))

func main() {
    flag.Parse()
    http.Handle("/", http.HandlerFunc(QR))
    err := http.ListenAndServe(*addr, nil)
    if err != nil {
        log.Fatal("ListenAndServe:", err)
    }
}

func QR(w http.ResponseWriter, req *http.Request) {
    templ.Execute(w, req.FormValue("s"))
}

const templateStr = `
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;QR Link Generator&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{if .}}
&lt;img src="http://chart.apis.google.com/chart?chs=300x300&amp;cht=qr&amp;choe=UTF-8&amp;chl={{.}}" /&gt;
&lt;br&gt;
{{.}}
&lt;br&gt;
&lt;br&gt;
{{end}}
&lt;form action="/" name=f method="GET"&gt;&lt;input maxLength=1024 size=70
name=s value="" title="Text to QR Encode"&gt;&lt;input type=submit
value="Show QR" name=qr&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
`</pre>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The pieces up to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">main</code>&nbsp;should be easy to follow. The one flag sets a default HTTP port for our server. The template variable&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">templ</code>&nbsp;is
 where the fun happens. It builds an HTML template that will be executed by the server to display the page; more about that in a moment.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">main</code>&nbsp;function parses the flags and, using the mechanism we talked about above, binds the function&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">QR</code>&nbsp;to the root path for the
 server. Then&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">http.ListenAndServe</code>&nbsp;is called to start the server; it blocks while the server runs.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
<code style="font-family:Menlo,monospace; font-size:14px">QR</code>&nbsp;just receives the request, which contains form data, and executes the template on the data in the form value named&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">s</code>.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The template package&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">html/template</code>&nbsp;is powerful; this program just touches on its capabilities. In essence, it rewrites a piece of HTML text on the fly by substituting elements derived from data
 items passed to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">templ.Execute</code>, in this case the form value. Within the template text (<code style="font-family:Menlo,monospace; font-size:14px">templateStr</code>), double-brace-delimited pieces
 denote template actions. The piece from&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">{{if .}}</code>&nbsp;to&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">{{end}}</code>&nbsp;executes only if the value of the current data item, called&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">.</code>&nbsp;(dot),
 is non-empty. That is, when the string is empty, this piece of the template is suppressed.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The two snippets&nbsp;<code style="font-family:Menlo,monospace; font-size:14px">{{.}}</code>&nbsp;say to show the data presented to the template—the query string—on the web page. The HTML template package automatically provides appropriate escaping so the text is safe
 to display.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
The rest of the template string is just the HTML to show when the page loads. If this is too quick an explanation, see the&nbsp;<a target="_blank" href="https://golang.org/pkg/html/template/" style="color:rgb(55,94,171); text-decoration:none">documentation</a>&nbsp;for
 the template package for a more thorough discussion.</p>
<p style="margin:20px; color:rgb(34,34,34); font-family:Helvetica,Arial,sans-serif; font-size:16px">
And there you have it: a useful web server in a few lines of code plus some data-driven HTML text. Go is powerful enough to make a lot happen in a few lines.</p>
<p><br>
</p>
					</div>
					

					
					<div class="row orig-info">
						<p>本文来自：<a href="https://studygolang.com/wr?u=http://blog.csdn.net" target="_blank" title="CSDN博客">CSDN博客</a></p>
						<p>感谢作者：leonzhouwei</p>
						<p>查看原文：<a href="https://studygolang.com/wr?u=http%3a%2f%2fblog.csdn.net%2fleonzhouwei%2farticle%2fdetails%2f41547331" target="_blank" title="Effective Go">Effective Go</a></p>
					</div>
					
				</div>
				
				<div class="content-buttons">
					<div class="pull-right c9 f11" style="line-height: 12px; padding-top: 3px; text-shadow: 0px 1px 0px #fff;">8097 次点击 &nbsp;</div>
					<a class="tb collect" href="javascript:;" title="加入收藏" data-objid="1976" data-objtype="1" data-collect="">加入收藏</a> 
					<a href="javascript:" onclick="window.open(&#39;http://service.weibo.com/share/share.php?url=https://studygolang.com/articles/1976&amp;title=&#39;+encodeURIComponent(&#39;Go语言中文网 - Effective Go by leonzhouwei #golang#&#39;), &#39;_blank&#39;, &#39;width=550,height=370&#39;);" class="tb">微博</a>
					<div id="content-thank">
						<a class="tb" href="javascript:;" title="赞" data-objid="1976" data-objtype="1" data-flag="">赞</a>
					</div>
				</div>
			</div>
			

			<div class="sep20"></div>
			<div class="box_white">
				<div class="cell subject">
					
					<div class="item-list">
					
						<a class="add-collection" href="javascript:"><i class="fa fa-plus"></i> 收入我的专栏</a>
					</div>
				</div>
			</div>

			<div class="sep20"></div>
			<div class="box_white">
				<div class="cell row">
					
					<div class="col-sm-6">上一篇：<a href="https://studygolang.com/articles/1975">关于编程语言学习的一些体会</a></div>
					
					
					<div class="col-sm-6 right">下一篇：<a href="https://studygolang.com/articles/1977">Go实例学：内建函数</a></div>
					
				</div>
			</div>

			<div class="sep20"></div>

			
			<div id="replies" class="box_white">
				<div class="cell">
					<div class="pull-right" style="margin: -3px -5px 0px 0px;">
					
						
						
						<a href="https://studygolang.com/tag/http" class="tag"><li class="fa fa-tag"></li> http</a>
						
						<a href="https://studygolang.com/tag/godoc" class="tag"><li class="fa fa-tag"></li> godoc</a>
						
						<a href="https://studygolang.com/tag/io" class="tag"><li class="fa fa-tag"></li> io</a>
						
						<a href="https://studygolang.com/tag/channel" class="tag"><li class="fa fa-tag"></li> channel</a>
						
					
					</div>
					<span class="c9"><span class="cmtnum">0</span> 回复 </span>
				</div>
				<div class="comment-list cell" data-objid="1976" data-objtype="1">
					<div class="words"><div class="text-center">暂无回复</div></div>
				</div>
			</div>

			
			
<div class="sep10"></div>
<div class="box_white page-comment">
	<div class="cell">添加一条新回复
	
	<span class="h2-tip">
	（您需要 <a class="c-log" href="javascript:openPop(&#39;#login-pop&#39;);">登录</a> 后才能回复 <a href="https://studygolang.com/user/register" class="c-reg"> 没有账号</a> ？）</span>
	
	</div>
	<div class="cell">
		<div class="row clearfix md-toolbar">
			<ul class="col-md-10 list-inline">
				<li class="edit cur"><a href="https://studygolang.com/articles/1976#" class="op">编辑</a></li>
				<li class="preview"><a href="https://studygolang.com/articles/1976#" class="op">预览</a></li>
				<li>
					<div class="nav reply-to dn" data-floor="" data-username="">
						<i class="fa fa-mail-reply" title=""></i>
						<a href="https://studygolang.com/articles/1976#reply" class="user" title=""></a>
						<a href="https://studygolang.com/articles/1976#" class="close"><i class="fa fa-close"></i></a>
					</div>
				</li>
			</ul>
			<div class="col-md-2 text-right">
				<i id="upload-img" class="glyphicon glyphicon-picture upload-img tool-tip" data-toggle="tooltip" data-placement="top" title="" data-original-title="上传图片" style="z-index: 1;"></i>
			<div id="html5_1cjdh80t81d8t1ogs7c51r0tm535_container" class="moxie-shim moxie-shim-html5" style="position: absolute; top: 1px; left: 117px; width: 13px; height: 13px; overflow: hidden; z-index: 0;"><input id="html5_1cjdh80t81d8t1ogs7c51r0tm535" type="file" style="font-size: 999px; opacity: 0; position: absolute; top: 0px; left: 0px; width: 100%; height: 100%;" accept=".jpg,.gif,.png,.bmp" tabindex="-1"></div></div>
		</div>
		<div class="submit" id="commentForm">
			<div class="text">
				<textarea id="comment-content" name="content" class="main-textarea need-autogrow" rows="8" style="overflow: hidden; min-height: 8em; height: 42px;"></textarea><div class="autogrow-textarea-mirror" style="display: none; word-wrap: break-word; padding: 5px; width: 837.5px; font-family: &quot;Helvetica Neue&quot;, &quot;Luxi Sans&quot;, &quot;DejaVu Sans&quot;, Tahoma, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, sans-serif; font-size: 14px; line-height: 15.6px;">.<br>.</div>
			</div>
			<div class="content-preview cell"></div>
			<div class="sub row">
				<ul class="help-block col-md-10">
					<li>请尽量让自己的回复能够对别人有帮助</li>
					<li class="markdown_tip">支持 Markdown 格式, <strong>**粗体**</strong>、~~删除线~~、<code>`单行代码`</code></li>
					<li>支持 @ 本站用户；支持表情（输入 : 提示），见 <a href="http://www.emoji-cheat-sheet.com/" target="_blank">Emoji cheat sheet</a></li>
					<li>图片支持拖拽、截图粘贴等方式上传</li>
				</ul>
				<div class="col-md-2 text-right"><button id="comment-submit" type="submit" title="提交" class="btn btn-default">提交</button></div>
			</div>
		</div>
	</div>
</div>

<style type="text/css">
#replies { margin-bottom: 15px; }
#replies .reply {
	margin: 0 -15px;
	padding: 15px 15px;
	position: relative;
	border-bottom: 1px solid #eee;
	padding-left: 74px;
}
#replies .reply .avatar {
	position: absolute;
	top: 15px;
	left: 15px;
}
.avatar-48 {
	width: 48px;
	height: 48px;
	border-radius: 120px;
}
.media-object {
	display: block;
}
.avatar-16 {
	width: 16px;
	height: 16px;
	border-radius: 120px;
}
#replies .reply .reply-to-block .info .media-object {
	display: inline-block;
	margin-right: 5px;
	vertical-align: top;
}
#replies .reply .reply-to-block .info {
	margin: 0;
}
#replies .reply .reply-to-block .info .user-name {
	font-weight: bold;
}
#replies .reply .reply-to-block {
	padding: 8px 15px;
	background: #f7f7f7;
	border-radius: 3px;
	margin-bottom: 10px;
}
.avatar .uface, .avatar .media-object {
	border-radius: 120px;
}
#replies .reply .infos {
	min-height: 48px;
}
#replies .reply .info {
	color: #999;
	margin-bottom: 6px;
	font-size: 12px;
}
#replies .reply .info .name {
	font-weight: bold;
	font-size: 13px;
}
#replies .reply .info .name a {
	color: #555;
}
#replies .reply .info .floor {
	color: #7AA87A;
}
#replies .reply .info a.time {
	color: #999;
	border-bottom: 1px dashed #ccc;
	text-decoration: none !important;
	cursor: pointer;
}
abbr[title] {
	border-bottom: 0px;
	cursor: pointer;
}
.opts {
	color: #666;
}
@media (min-width: 1026px) {
	#replies .reply .hideable {
		display: none;
	}
}
#replies .reply .opts a {
	display: inline-block;
	vertical-align: baseline;
	line-height: 22px;
	padding: 2px 5px;
	height: 22px;
	min-width: 22px;
	text-align: center;
}
#replies .info .opts a {
	font-size: 13px;
	margin-left: 5px;
	color: #999;
}
#replies .info .opts a.edit {
	display: none;
}
.markdown {
	position: relative;
	letter-spacing: .03em;
	font-size: 15px;
	text-overflow: ellipsis;
	word-wrap: break-word;
}
.markdown img.twemoji {
	width: 20px;
}
.markdown img {
	vertical-align: top;
	max-width: 100%;
}
.markdown p {
	font-size: 14px;
	line-height: 26px;
	margin-bottom: 0;
	color: #000;
}
.md-toolbar .reply-to {
    padding-top: 3px;
    padding-left: 8px;
}
.close {
    float: right;
    font-size: 21px;
    font-weight: 700;
    line-height: 1;
    color: #000;
    text-shadow: 0 1px 0 #fff;
    filter: alpha(opacity=20);
    opacity: .2;
}
a.close:hover {
	background-color: #d0d0d0;
    color: #666
}
.md-toolbar .reply-to .close {
    font-size: 14px;
    margin-left: 5px;
    margin-top: 1px;
}

</style>

<script type="text/x-jsrender" id="one-comment">
<div class="reply [%if is_new%]light[%/if%]" id="reply-[%:comment.floor%]">
	<div data-floor="[%:comment.floor%]">
		<div class="avatar"><a title="[%:user.username%]" href="/user/[%:user.username%]"><img class="media-object avatar-48" src="[%:user.avatar%]" alt="[%:user.username%]"></a></div>
			<div class="infos">
				<div class="info">
					<span class="name">
						<a class="user-name" data-name="[%:user.name%]" href="/user/[%:user.username%]">[%:user.username%]</a>
					</span> ·
					<span class="floor">#[%:comment.floor%]</span> ·
					<abbr class="timeago" title="[%:comment.ctime%]">[%:comment.cmt_time%]</abbr>
					<span class="opts pull-right">
						<span class="op-reply hideable">
						  <a data-floor="[%:comment.floor%]" data-username="[%:user.username%]" title="回复此楼" class="btn-reply fa fa-mail-reply" href="#"></a>
						</span>
						
					</span>
				</div>
				[%if comment.reply_floor > 0%]
				<div class="reply-to-block">
					<div class="info reply_user">
						对
						<a data-remote="true" href="/user/[%:comment.reply_user.username%]">
							<img class="media-object avatar-16" src="[%:comment.reply_user.avatar%]" alt="[%:comment.reply_user.username%]"><span class="user-name">[%:comment.reply_user.username%]</span>
						</a>
						<a href="#reply-[%:comment.reply_floor%]"><span class="reply-floor">#[%:comment.reply_floor%]</span></a> 回复
					</div>
					<div class="markdown dn">
						<p>[%:comment.reply_content%]</p>
					</div>
				</div>
				[%/if%]

			<div class="markdown">
				<p>[%:comment.content%]</p>
			</div>
		</div>
	</div>
</div>
</script>


			

			
		</div>
	</div>
	<div class="col-md-3 col-sm-6">
		<div class="sep20"></div>
		<div class="box_white sidebar">
	
	<div class="top">
		<h3 class="title"><i class="glyphicon glyphicon-user"></i> 用户登录</h3>
	</div>
	<div class="sb-content inner_content" style="padding-bottom: 0;">
		<form action="https://studygolang.com/account/login" method="post" class="form-horizontal login" role="form" style="padding-top: 0; padding-bottom: 0;">
			<div class="form-group">
				<div class="col-sm-10">
					<input type="text" class="form-control input-sm" id="username" name="username" placeholder="请填写用户名或邮箱">
				</div>
			</div>
			<div class="form-group">
				<div class="col-sm-10">
					<input type="password" class="form-control input-sm" id="passwd" name="passwd" placeholder="请填写密码">
				</div>
			</div>
			<div class="form-group">
				<div class="col-sm-10">
					<div class="checkbox">
						<label>
							<input id="user_remember_me" name="remember_me" type="checkbox" value="1" checked="checked">	记住登录状态
						</label>
						<input class="btn btn-default btn-sm" data-disable-with="正在登录" name="commit" type="submit" value="登录">
					</div>
					<div class="sep10"></div>
					<a href="https://studygolang.com/oauth/github/login" class="btn btn-default btn-sm">
						<i class="fa fa-github" aria-hidden="true"></i>
						GitHub 登录
					</a>
				</div>
			</div>
		</form>
	</div>
	
</div>





		
		<div class="box_white sidebar" id="ad-right1">
			
				<script async="" src="./Effective Go - Go语言中文网 - Golang中文社区_files/adsbygoogle.js.下载"></script>
<ins class="adsbygoogle" style="display: block; height: 939px;" data-ad-format="autorelaxed" data-ad-client="ca-pub-4512014793067058" data-ad-slot="4230018468" data-adsbygoogle-status="done"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:939px;margin:0;padding:0;position:relative;visibility:visible;width:273px;background-color:transparent;"><ins id="aswift_0_anchor" style="display:block;border:none;height:939px;margin:0;padding:0;position:relative;visibility:visible;width:273px;background-color:transparent;"><iframe width="273" height="939" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;width:273px;height:939px;" src="./Effective Go - Go语言中文网 - Golang中文社区_files/saved_resource(6).html"></iframe></ins></ins></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			
		</div>
		

		<div class="box_white sidebar">
	<div class="top">
		<h3 class="title"><i class="glyphicon glyphicon-stats"></i>&nbsp;今日阅读排行</h3>
	</div>
	<div class="sb-content">
		<div class="rank-list" data-objtype="1" data-limit="10" data-rank_type="today">
			<ul class="list-unstyled"><li><img src="./Effective Go - Go语言中文网 - Golang中文社区_files/rank_medal1.png" width="20px"><a href="https://studygolang.com/articles/17?fr=sidebar" title="Windows下搭建go语言开发环境 以及 开发IDE (附下载链接)">Windows下搭建go语言开发环境 以及 开发IDE (附下载链接)</a> - 143 阅读</li><li><img src="./Effective Go - Go语言中文网 - Golang中文社区_files/rank_medal2.png" width="20px"><a href="https://studygolang.com/articles/1759?fr=sidebar" title="我为什么放弃Go语言">我为什么放弃Go语言</a> - 124 阅读</li><li><img src="./Effective Go - Go语言中文网 - Golang中文社区_files/rank_medal3.png" width="20px"><a href="https://studygolang.com/articles/2228?fr=sidebar" title="【玩转Golang】slice切片的操作——切片的追加、删除、插入等">【玩转Golang】slice切片的操作——切片的追加、删除、插入等</a> - 99 阅读</li><li><em>4</em><a href="https://studygolang.com/articles/2379?fr=sidebar" title="golang语言中map的初始化及使用">golang语言中map的初始化及使用</a> - 92 阅读</li><li><em>5</em><a href="https://studygolang.com/articles/2644?fr=sidebar" title="golang fmt格式“占位符”">golang fmt格式“占位符”</a> - 91 阅读</li><li><em>6</em><a href="https://studygolang.com/articles/7708?fr=sidebar" title="Golang优秀开源项目汇总（持续更新。。。）">Golang优秀开源项目汇总（持续更新。。。）</a> - 88 阅读</li><li><em>7</em><a href="https://studygolang.com/articles/10155?fr=sidebar" title="服务器开发利器golang context用法详解">服务器开发利器golang context用法详解</a> - 77 阅读</li><li><em>8</em><a href="https://studygolang.com/articles/10589?fr=sidebar" title="Golang官方依赖管理工具：dep">Golang官方依赖管理工具：dep</a> - 74 阅读</li><li><em>9</em><a href="https://studygolang.com/articles/11819?fr=sidebar" title="Golang 微框架 Gin 简介">Golang 微框架 Gin 简介</a> - 74 阅读</li><li><em>10</em><a href="https://studygolang.com/articles/13808?fr=sidebar" title="我有点不想当程序员了，有没有人开导我几句，骂我几句也行？">我有点不想当程序员了，有没有人开导我几句，骂我几句也行？</a> - 68 阅读</li></ul>
		</div>
	</div>
</div>
		
		
		<div class="box_white sidebar" id="ad-right2">
			
				<script async="" src="./Effective Go - Go语言中文网 - Golang中文社区_files/adsbygoogle.js.下载"></script>
<!-- 侧边栏自适应 -->
<ins class="adsbygoogle" style="display: inline-block; min-width: 270px; max-width: 970px; width: 272.5px; height: 290px;" data-ad-client="ca-pub-4512014793067058" data-ad-slot="3487838313" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:290px;margin:0;padding:0;position:relative;visibility:visible;width:273px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:290px;margin:0;padding:0;position:relative;visibility:visible;width:273px;background-color:transparent;"><iframe width="273" height="290" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:273px;height:290px;" src="./Effective Go - Go语言中文网 - Golang中文社区_files/saved_resource(7).html"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			
		</div>
		

		<div class="box_white sidebar">
	<div class="top">
		<h3 class="title"><i class="glyphicon glyphicon-stats"></i>&nbsp;一周阅读排行</h3>
	</div>
	<div class="sb-content">
		<div class="rank-list" data-objtype="1" data-limit="10" data-rank_type="week">
			<ul class="list-unstyled"><li><img src="./Effective Go - Go语言中文网 - Golang中文社区_files/rank_medal1.png" width="20px"><a href="https://studygolang.com/articles/1759?fr=sidebar" title="我为什么放弃Go语言">我为什么放弃Go语言</a> - 1134 阅读</li><li><img src="./Effective Go - Go语言中文网 - Golang中文社区_files/rank_medal2.png" width="20px"><a href="https://studygolang.com/articles/2228?fr=sidebar" title="【玩转Golang】slice切片的操作——切片的追加、删除、插入等">【玩转Golang】slice切片的操作——切片的追加、删除、插入等</a> - 993 阅读</li><li><img src="./Effective Go - Go语言中文网 - Golang中文社区_files/rank_medal3.png" width="20px"><a href="https://studygolang.com/articles/2379?fr=sidebar" title="golang语言中map的初始化及使用">golang语言中map的初始化及使用</a> - 736 阅读</li><li><em>4</em><a href="https://studygolang.com/articles/2644?fr=sidebar" title="golang fmt格式“占位符”">golang fmt格式“占位符”</a> - 706 阅读</li><li><em>5</em><a href="https://studygolang.com/articles/7708?fr=sidebar" title="Golang优秀开源项目汇总（持续更新。。。）">Golang优秀开源项目汇总（持续更新。。。）</a> - 697 阅读</li><li><em>6</em><a href="https://studygolang.com/articles/9785?fr=sidebar" title="go依赖管理-govendor">go依赖管理-govendor</a> - 685 阅读</li><li><em>7</em><a href="https://studygolang.com/articles/10572?fr=sidebar" title="初探 Go 的编译命令执行过程">初探 Go 的编译命令执行过程</a> - 592 阅读</li><li><em>8</em><a href="https://studygolang.com/articles/10589?fr=sidebar" title="Golang官方依赖管理工具：dep">Golang官方依赖管理工具：dep</a> - 579 阅读</li><li><em>9</em><a href="https://studygolang.com/articles/11819?fr=sidebar" title="Golang 微框架 Gin 简介">Golang 微框架 Gin 简介</a> - 556 阅读</li><li><em>10</em><a href="https://studygolang.com/articles/13769?fr=sidebar" title="Gopher面试中的Coding">Gopher面试中的Coding</a> - 530 阅读</li></ul>
		</div>
	</div>
</div>
		
	</div>
</div>

<link rel="stylesheet" href="./Effective Go - Go语言中文网 - Golang中文社区_files/modal.min.css">
<div class="modal contribute-modal animated" style="display: none;">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close">×</button>
                <h4 class="modal-title">
                    给该专栏投稿
                    <a href="https://studygolang.com/articles/new" class="new-note-btn">写篇新文章</a>
                </h4>
                <span class="notice">每篇文章有总共有 5 次投稿机会</span>
                <div>
                    <input type="text" placeholder="搜索我的文章" class="search-input">
                    <a class="search-btn">
                        <i class="fa fa-search" aria-hidden="true" style="margin: 8px -1px 0 0;display: block;"></i>
                    </a>
                </div>
            </div>
            <div class="modal-body">
                <ul id="contribute-note-list"></ul>
                <div class="modal-notes-placeholder" style="display: none;">
                    <div class="text"></div>
                    <div class="btn"></div>
                </div>
            </div>
            <div class="modal-footer"></div>
        </div>
    </div>
</div>


<div class="modal animated add-self" style="display: none;">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" data-dismiss="modal" class="close">×</button>
                <h4 class="modal-title">收入到我管理的专栏
                    <span class="new-collection-btn"><a href="https://studygolang.com/subject/new" target="_blank">新建专栏</a></span>
                </h4>
            </div>
            <div class="modal-body">
                <div class="search">
                    <input type="search" name="search-self" placeholder="搜索我管理的专栏">
                    <a class="search-btn">
                        <i class="fa fa-search" aria-hidden="true" style="margin: 6px 1px 0 0;display: block;"></i>
                    </a>
                </div>
                <ul id="self-note-list"></ul>
                <div class="modal-collections-placeholder" style="display: none;">
                    <div class="avatar"></div>
                    <div class="wrap">
                        <div class="btn"></div>
                        <div class="name"></div>
                        <div class="text"></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer"></div>
        </div>
    </div>
</div>



<template id="content_tpl"></template>



		</div>
	</div><iframe id="google_osd_static_frame_5539651057205" name="google_osd_static_frame" style="display: none; width: 0px; height: 0px;" src="./Effective Go - Go语言中文网 - Golang中文社区_files/saved_resource(8).html"></iframe>
	<div class="sep10"></div>
	<div class="google-auto-placed" style="text-align: center; width: 100%; height: auto; clear: both;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-4512014793067058" data-adsbygoogle-status="done" style="display: block; margin: 10px auto; background-color: transparent; height: 90px;"><ins id="aswift_9_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:1200px;background-color:transparent;"><ins id="aswift_9_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:1200px;background-color:transparent;"><iframe width="1200" height="90" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_9" name="aswift_9" style="left:0;position:absolute;top:0;width:1200px;height:90px;" src="./Effective Go - Go语言中文网 - Golang中文社区_files/saved_resource(9).html"></iframe></ins></ins></ins></div><footer id="bottom">
		<div class="container nav-content">
			<div class="inner_content">
				<div class="sep10"></div>   
				<strong>
					
					<a href="https://studygolang.com/wiki/about" class="dark">关于</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://studygolang.com/wiki/faq" class="dark">FAQ</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://studygolang.com/wiki/contributors" class="dark">贡献者</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://studygolang.com/go/feedback" class="dark">反馈</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://github.com/studygolang" class="dark">Github</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="http://weibo.com/studygolang" class="dark">新浪微博</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://play.studygolang.com/" class="dark">Play</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://studygolang.com/wiki/duty" class="dark">免责声明</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://studygolang.com/wiki/contact" class="dark">联系我们</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://studygolang.com/wiki/donate" class="dark">捐赠</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://studygolang.com/wiki/cool" class="dark">酷站</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://studygolang.com/feed.html" class="dark">Feed订阅</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<span id="onlineusers">1470</span> 人在线
				</strong>
				&nbsp;<span class="cc">最高记录 <span id="maxonline">2928</span></span>
				<div class="sep20"></div>
				©2013-2018 studygolang.com Go语言中文网，中国 Golang 社区，致力于构建完善的 Golang 中文社区，Go语言爱好者的学习家园。
				<div class="sep5"></div>
				Powered by <a href="https://github.com/studygolang/studygolang">StudyGolang(Golang + MySQL)</a> &nbsp;<span class="snow">•</span>&nbsp;<span class="snow">·</span>&nbsp;CDN 采用 <a href="https://portal.qiniu.com/signup?code=3lfz4at7pxfma" title="七牛云" class="dark" target="_blank">七牛云</a>
				<div class="sep20"></div>
				<span class="small cc">VERSION: V3.5.0&nbsp;<span class="snow">·</span>&nbsp;11.255107ms&nbsp;<span class="snow">·</span>&nbsp;<strong>为了更好的体验，本站推荐使用 Chrome 或 Firefox 浏览器</strong></span>
				<div class="sep20"></div>
				<span class="f12 c9"><a href="http://www.miibeian.gov.cn/" target="_blank" rel="nofollow">京ICP备14030343号-1</a></span>
				<div class="sep10"></div>
			</div>
		</div>
	</footer>

	<div id="gotop" style="display: block;"></div>

	
	<input type="hidden" id="is_login_status" value="0">
	<div class="pop login-pop" id="login-pop">
		<div style="position: relative;"><span class="close" style="position: absolute; right: -15px; top: -15px; cursor: pointer; color: #000; font-size: 13px;">X</span></div>
		<div class="login-form">
			<div class="error text-center"></div>
			<div class="text-center" style="margin-bottom: 5px;">登录和大家一起探讨吧</div>
			<form action="https://studygolang.com/articles/1976#" method="post" class="form-horizontal" role="form">
				<div class="form-group">
					<label for="username" class="col-sm-3 control-label">用户名</label>
					<div class="col-sm-9 form-input">
						<input type="text" class="form-control" id="form_username" name="username" placeholder="请填写用户名或邮箱">
					</div>
				</div>
				<div class="form-group">
					<label for="passwd" class="col-sm-3 control-label">密码</label>
					<div class="col-sm-9 form-input">
						<input type="password" class="form-control" id="form_passwd" name="passwd" placeholder="密码">
					</div>
				</div>
				<div class="form-group">
					<div class="col-sm-offset-2 col-sm-10">
						<div class="checkbox">
							<label>
								<input id="user_remember_me" name="remember_me" type="checkbox" value="1" checked="checked">	记住登录状态
							</label>
							<button type="submit" id="login-btn" class="btn btn-default btn-sm">登录</button>
						</div>
					</div>
				</div>
				<div class="form-group">
					<div class="col-sm-offset-2 col-sm-10">
						<a id="login-github" href="https://studygolang.com/oauth/github/login" class="btn btn-default btn-sm pull-left">
							<i class="fa fa-github" aria-hidden="true"></i>
							GitHub 登录
						</a>
						<div class="forget">
							<a href="https://studygolang.com/account/forgetpwd" title="点击找回密码">忘记密码？</a>
						</div>
						<div class="register">
							<span>还不是会员</span><a href="https://studygolang.com/account/register">现在注册</a>
						</div>
					</div>
				</div>
			</form>
		</div>
	</div>
	<div id="sg-overlay"></div>
	
	
	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/jquery.min.js.下载"></script>
	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/bootstrap.min.js.下载"></script>
	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/jquery.timeago.min.js.下载"></script>
	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/zoom.min.js.下载"></script>
	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/marked.min.js.下载"></script>
	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/jquery.caret.min.js.下载"></script>
	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/emojify.min.js.下载"></script>

	<script type="text/javascript">
	var uid =  0 ;
	var isHttps =  true ,
		cdnDomain = "https:\/\/static.studygolang.com\/";
	if (isHttps) {
		var wsUrl = 'wss://studygolang.com/ws?uid='+uid;
	} else {
		var wsUrl = 'ws://studygolang.com/ws?uid='+uid;
	}
	var GLaunchTime =  1532509948 *1000;
	</script>
	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/lscache.min.js.下载"></script>
	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/jsrender.min.js.下载"></script>
	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/plupload.full.min.js.下载"></script>
	<script type="text/javascript">
	$.views.settings.delimiters("[%", "%]");
	
	</script>

	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/sg_libs.min.js.下载"></script>
	<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/sg_base.min.js.下载"></script>

	

<script type="text/javascript" src="./Effective Go - Go语言中文网 - Golang中文社区_files/articles.min.js.下载"></script>

<script type="text/javascript">

SG.SIDE_BARS = [
	"/rank/view",
];

var keyprefix = 'article';
var objid =  1976 ;

$(function(){
	
	
	
	$('.need-autogrow').autoGrow();
	
	loadComments();

	
	$('#wrapper .content').on('mousedown', 'a', function(evt){
		var url = $(this).attr('href');
		
		$(this).attr('href', url);
		$(this).attr('target', '_blank');
	});

	var len = '转自：https:\/\/golang.org\/doc\/effective_go.html Effective Go IntroductionExamplesFormattingCommentaryNamesPackage namesGettersInterface namesMixedCapsSemicolonsControl structuresIfRedeclaration and reassignmentForSwitchType switchFunctionsMultiple return valuesNamed result parametersDeferDataAllocation with newConstructors and composite literalsAllocation with makeArraysSlicesTwo-dimensional slicesMapsPrintingAppendInitialization ConstantsVariablesThe init functionMethodsPointers vs. ValuesInterfaces and other typesInterfacesConversionsInterface conversions and type assertionsGeneralityInterfaces and methodsThe blank identifierThe blank identifier in multiple assignmentUnused imports and variablesImport for side effectInterface checksEmbeddingConcurrencyShare by communicatingGoroutinesChannelsChannels of channelsParallelizationA leaky bufferErrorsPanicRecoverA web server Introduction Go is a new language. Although it borrows ideas from existing languages, it has unusual properties that make effective Go programs different in character from programs written in its relatives. A straightforward translation of a C\x2b\x2b or Java program into Go is unlikely to produce a satisfactory result—Java programs are written in Java, not Go. On the other hand, thinking about the problem from a Go perspective could produce a successful but quite different program. In other words, to write Go well, it\x27s important to understand its properties and idioms. It\x27s also important to know the established conventions for programming in Go, such as naming, formatting, program construction, and so on, so that programs you write will be easy for other Go programmers to understand. This document gives tips for writing clear, idiomatic Go code. It augments the language specification, the Tour of Go, and How to Write Go Code, all of which you should read first. Examples The Go package sources are intended to serve not only as the core library but also as examples of how to use the language. Moreover, many of the packages contain working, self-contained executable examples you can run directly from the golang.org web site, such as this one (if necessary, click on the word \x22Example\x22 to open it up). If you have a question about how to approach a problem or how something might be implemented, the documentation, code and examples in the library can provide answers, ideas and background. Formatting Formatting issues are the most contentious but the least consequential. People can adapt to different formatting styles but it\x27s better if they don\x27t have to, and less time is devoted to the topic if everyone adheres to the same style. The problem is how to approach this Utopia without a long prescriptive style guide. With Go we take an unusual approach and let the machine take care of most formatting issues. The gofmt program (also available as go fmt, which operates at the package level rather than source file level) reads a Go program and emits the source in a standard style of indentation and vertical alignment, retaining and if necessary reformatting comments. If you want to know how to handle some new layout situation, run gofmt; if the answer doesn\x27t seem right, rearrange your program (or file a bug about gofmt), don\x27t work around it. As an example, there\x27s no need to spend time lining up the comments on the fields of a structure. Gofmt will do that for you. Given the declaration type T struct { name string \/\/ name of the object value int \/\/ its value } gofmt will line up the columns: type T struct { name string \/\/ name of the object value int \/\/ its value } All Go code in the standard packages has been formatted with gofmt. Some formatting details remain. Very briefly: IndentationWe use tabs for indentation and gofmt emits them by default. Use spaces only if you must.Line lengthGo has no line length limit. Don\x27t worry about overflowing a punched card. If a line feels too long, wrap it and indent with an extra tab.ParenthesesGo needs fewer parentheses than C and Java: control structures (if, for, switch) do not have parentheses in their syntax. Also, the operator precedence hierarchy is shorter and clearer, so x\x3c\x3c8 \x2b y\x3c\x3c16 means what the spacing implies, unlike in the other languages. Commentary Go provides C-style \/* *\/ block comments and C\x2b\x2b-style \/\/ line comments. Line comments are the norm; block comments appear mostly as package comments, but are useful within an expression or to disable large swaths of code. The program—and web server—godoc processes Go source files to extract documentation about the contents of the package. Comments that appear before top-level declarations, with no intervening newlines, are extracted along with the declaration to serve as explanatory text for the item. The nature and style of these comments determines the quality of the documentation godoc produces. Every package should have a package comment, a block comment preceding the package clause. For multi-file packages, the package comment only needs to be present in one file, and any one will do. The package comment should introduce the package and provide information relevant to the package as a whole. It will appear first on the godoc page and should set up the detailed documentation that follows. \/* Package regexp implements a simple library for regular expressions. The syntax of the regular expressions accepted is: regexp: concatenation { \x27|\x27 concatenation } concatenation: { closure } closure: term [ \x27*\x27 | \x27\x2b\x27 | \x27?\x27 ] term: \x27^\x27 \x27$\x27 \x27.\x27 character \x27[\x27 [ \x27^\x27 ] character-ranges \x27]\x27 \x27(\x27 regexp \x27)\x27 *\/ package regexp If the package is simple, the package comment can be brief. \/\/ Package path implements utility routines for \/\/ manipulating slash-separated filename paths. Comments do not need extra formatting such as banners of stars. The generated output may not even be presented in a fixed-width font, so don\x27t depend on spacing for alignment—godoc, like gofmt, takes care of that. The comments are uninterpreted plain text, so HTML and other annotations such as _this_ will reproduce verbatim and should not be used. One adjustment godoc does do is to display indented text in a fixed-width font, suitable for program snippets. The package comment for the fmtpackage uses this to good effect. Depending on the context, godoc might not even reformat comments, so make sure they look good straight up: use correct spelling, punctuation, and sentence structure, fold long lines, and so on. Inside a package, any comment immediately preceding a top-level declaration serves as a doc comment for that declaration. Every exported (capitalized) name in a program should have a doc comment. Doc comments work best as complete sentences, which allow a wide variety of automated presentations. The first sentence should be a one-sentence summary that starts with the name being declared. \/\/ Compile parses a regular expression and returns, if successful, a Regexp \/\/ object that can be used to match against text. func Compile(str string) (regexp *Regexp, err error) { If the name always begins the comment, the output of godoc can usefully be run through grep. Imagine you couldn\x27t remember the name \x22Compile\x22 but were looking for the parsing function for regular expressions, so you ran the command, $ godoc regexp | grep parse If all the doc comments in the package began, \x22This function...\x22, grep wouldn\x27t help you remember the name. But because the package starts each doc comment with the name, you\x27d see something like this, which recalls the word you\x27re looking for. $ godoc regexp | grep parse Compile parses a regular expression and returns, if successful, a Regexp parsed. It simplifies safe initialization of global variables holding cannot be parsed. It simplifies safe initialization of global variables $ Go\x27s declaration syntax allows grouping of declarations. A single doc comment can introduce a group of related constants or variables. Since the whole declaration is presented, such a comment can often be perfunctory. \/\/ Error codes returned by failures to parse an expression. var ( ErrInternal = errors.New(\x22regexp: internal error\x22) ErrUnmatchedLpar = errors.New(\x22regexp: unmatched \x27(\x27\x22) ErrUnmatchedRpar = errors.New(\x22regexp: unmatched \x27)\x27\x22) ... ) Grouping can also indicate relationships between items, such as the fact that a set of variables is protected by a mutex. var ( countLock sync.Mutex inputCount uint32 outputCount uint32 errorCount uint32 ) Names Names are as important in Go as in any other language. They even have semantic effect: the visibility of a name outside a package is determined by whether its first character is upper case. It\x27s therefore worth spending a little time talking about naming conventions in Go programs. Package names When a package is imported, the package name becomes an accessor for the contents. After import \x22bytes\x22 the importing package can talk about bytes.Buffer. It\x27s helpful if everyone using the package can use the same name to refer to its contents, which implies that the package name should be good: short, concise, evocative. By convention, packages are given lower case, single-word names; there should be no need for underscores or mixedCaps. Err on the side of brevity, since everyone using your package will be typing that name. And don\x27t worry about collisions a priori. The package name is only the default name for imports; it need not be unique across all source code, and in the rare case of a collision the importing package can choose a different name to use locally. In any case, confusion is rare because the file name in the import determines just which package is being used. Another convention is that the package name is the base name of its source directory; the package in src\/pkg\/encoding\/base64 is imported as \x22encoding\/base64\x22 but has name base64, not encoding_base64 and not encodingBase64. The importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid stutter. (Don\x27t use the import . notation, which can simplify tests that must run outside the package they are testing, but should otherwise be avoided.) For instance, the buffered reader type in the bufio package is called Reader, not BufReader, because users see it as bufio.Reader, which is a clear, concise name. Moreover, because imported entities are always addressed with their package name, bufio.Reader does not conflict with io.Reader. Similarly, the function to make new instances of ring.Ring—which is the definition of a constructor in Go—would normally be called NewRing, but since Ring is the only type exported by the package, and since the package is called ring, it\x27s called just New, which clients of the package see as ring.New. Use the package structure to help you choose good names. Another short example is once.Do; once.Do(setup) reads well and would not be improved by writing once.DoOrWaitUntilDone(setup). Long names don\x27t automatically make things more readable. A helpful doc comment can often be more valuable than an extra long name. Getters Go doesn\x27t provide automatic support for getters and setters. There\x27s nothing wrong with providing getters and setters yourself, and it\x27s often appropriate to do so, but it\x27s neither idiomatic nor necessary to put Get into the getter\x27s name. If you have a field called owner (lower case, unexported), the getter method should be called Owner (upper case, exported), not GetOwner. The use of upper-case names for export provides the hook to discriminate the field from the method. A setter function, if needed, will likely be called SetOwner. Both names read well in practice: owner := obj.Owner() if owner != user { obj.SetOwner(user) } Interface names By convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: Reader, Writer, Formatter,CloseNotifier etc. There are a number of such names and it\x27s productive to honor them and the function names they capture. Read, Write, Close, Flush, String and so on have canonical signatures and meanings. To avoid confusion, don\x27t give your method one of those names unless it has the same signature and meaning. Conversely, if your type implements a method with the same meaning as a method on a well-known type, give it the same name and signature; call your string-converter method String notToString. MixedCaps Finally, the convention in Go is to use MixedCaps or mixedCaps rather than underscores to write multiword names. Semicolons Like C, Go\x27s formal grammar uses semicolons to terminate statements, but unlike in C, those semicolons do not appear in the source. Instead the lexer uses a simple rule to insert semicolons automatically as it scans, so the input text is mostly free of them. The rule is this. If the last token before a newline is an identifier (which includes words like int and float64), a basic literal such as a number or string constant, or one of the tokens break continue fallthrough return \x2b\x2b -- ) } the lexer always inserts a semicolon after the token. This could be summarized as, “if the newline comes after a token that could end a statement, insert a semicolon”. A semicolon can also be omitted immediately before a closing brace, so a statement such as go func() { for { dst \x3c- \x3c-src } }() needs no semicolons. Idiomatic Go programs have semicolons only in places such as for loop clauses, to separate the initializer, condition, and continuation elements. They are also necessary to separate multiple statements on a line, should you write code that way. One consequence of the semicolon insertion rules is that you cannot put the opening brace of a control structure (if, for, switch, or select) on the next line. If you do, a semicolon will be inserted before the brace, which could cause unwanted effects. Write them like this if i \x3c f() { g() } not like this if i \x3c f() \/\/ wrong! { \/\/ wrong! g() } Control structures The control structures of Go are related to those of C but differ in important ways. There is no do or while loop, only a slightly generalized for; switch is more flexible; if andswitch accept an optional initialization statement like that of for; break and continue statements take an optional label to identify what to break or continue; and there are new control structures including a type switch and a multiway communications multiplexer, select. The syntax is also slightly different: there are no parentheses and the bodies must always be brace-delimited. If In Go a simple if looks like this: if x \x3e 0 { return y } Mandatory braces encourage writing simple if statements on multiple lines. It\x27s good style to do so anyway, especially when the body contains a control statement such as a return or break. Since if and switch accept an initialization statement, it\x27s common to see one used to set up a local variable. if err := file.Chmod(0664); err != nil { log.Print(err) return err } In the Go libraries, you\x27ll find that when an if statement doesn\x27t flow into the next statement—that is, the body ends in break, continue, goto, or return—the unnecessary elseis omitted. f, err := os.Open(name) if err != nil { return err } codeUsing(f) This is an example of a common situation where code must guard against a sequence of error conditions. The code reads well if the successful flow of control runs down the page, eliminating error cases as they arise. Since error cases tend to end in return statements, the resulting code needs no else statements. f, err := os.Open(name) if err != nil { return err } d, err := f.Stat() if err != nil { f.Close() return err } codeUsing(f, d) Redeclaration and reassignment An aside: The last example in the previous section demonstrates a detail of how the := short declaration form works. The declaration that calls os.Open reads, f, err := os.Open(name) This statement declares two variables, f and err. A few lines later, the call to f.Stat reads, d, err := f.Stat() which looks as if it declares d and err. Notice, though, that err appears in both statements. This duplication is legal: err is declared by the first statement, but only re-assigned in the second. This means that the call to f.Stat uses the existing err variable declared above, and just gives it a new value. In a := declaration a variable v may appear even if it has already been declared, provided: this declaration is in the same scope as the existing declaration of v (if v is already declared in an outer scope, the declaration will create a new variable §),the corresponding value in the initialization is assignable to v, andthere is at least one other variable in the declaration that is being declared anew. This unusual property is pure pragmatism, making it easy to use a single err value, for example, in a long if-else chain. You\x27ll see it used often. § It\x27s worth noting here that in Go the scope of function parameters and return values is the same as the function body, even though they appear lexically outside the braces that enclose the body. For The Go for loop is similar to—but not the same as—C\x27s. It unifies for and while and there is no do-while. There are three forms, only one of which has semicolons. \/\/ Like a C for for init; condition; post { } \/\/ Like a C while for condition { } \/\/ Like a C for(;;) for { } Short declarations make it easy to declare the index variable right in the loop. sum := 0 for i := 0; i \x3c 10; i\x2b\x2b { sum \x2b= i } If you\x27re looping over an array, slice, string, or map, or reading from a channel, a range clause can manage the loop. for key, value := range oldMap { newMap[key] = value } If you only need the first item in the range (the key or index), drop the second: for key := range m { if key.expired() { delete(m, key) } } If you only need the second item in the range (the value), use the blank identifier, an underscore, to discard the first: sum := 0 for _, value := range array { sum \x2b= value } The blank identifier has many uses, as described in a later section. For strings, the range does more work for you, breaking out individual Unicode code points by parsing the UTF-8. Erroneous encodings consume one byte and produce the replacement rune U\x2bFFFD. (The name (with associated builtin type) rune is Go terminology for a single Unicode code point. See the language specification for details.) The loop for pos, char := range \x22日本\\x80語\x22 { \/\/ \\x80 is an illegal UTF-8 encoding fmt.Printf(\x22character %#U starts at byte position %d\\n\x22, char, pos) } prints character U\x2b65E5 \x27日\x27 starts at byte position 0 character U\x2b672C \x27本\x27 starts at byte position 3 character U\x2bFFFD \x27�\x27 starts at byte position 6 character U\x2b8A9E \x27語\x27 starts at byte position 7 Finally, Go has no comma operator and \x2b\x2b and -- are statements not expressions. Thus if you want to run multiple variables in a for you should use parallel assignment (although that precludes \x2b\x2b and --). \/\/ Reverse a for i, j := 0, len(a)-1; i \x3c j; i, j = i\x2b1, j-1 { a[i], a[j] = a[j], a[i] } Switch Go\x27s switch is more general than C\x27s. The expressions need not be constants or even integers, the cases are evaluated top to bottom until a match is found, and if theswitch has no expression it switches on true. It\x27s therefore possible—and idiomatic—to write an if-else-if-else chain as a switch. func unhex(c byte) byte { switch { case \x270\x27 \x3c= c \x26\x26 c \x3c= \x279\x27: return c - \x270\x27 case \x27a\x27 \x3c= c \x26\x26 c \x3c= \x27f\x27: return c - \x27a\x27 \x2b 10 case \x27A\x27 \x3c= c \x26\x26 c \x3c= \x27F\x27: return c - \x27A\x27 \x2b 10 } return 0 } There is no automatic fall through, but cases can be presented in comma-separated lists. func shouldEscape(c byte) bool { switch c { case \x27 \x27, \x27?\x27, \x27\x26\x27, \x27=\x27, \x27#\x27, \x27\x2b\x27, \x27%\x27: return true } return false } Although they are not nearly as common in Go as some other C-like languages, break statements can be used to terminate a switch early. Sometimes, though, it\x27s necessary to break out of a surrounding loop, not the switch, and in Go that can be accomplished by putting a label on the loop and \x22breaking\x22 to that label. This example shows both uses. Loop: for n := 0; n \x3c len(src); n \x2b= size { switch { case src[n] \x3c sizeOne: if validateOnly { break } size = 1 update(src[n]) case src[n] \x3c sizeTwo: if n\x2b1 \x3e= len(src) { err = errShortInput break Loop } if validateOnly { break } size = 2 update(src[n] \x2b src[n\x2b1]\x3c\x3cshift) } } Of course, the continue statement also accepts an optional label but it applies only to loops. To close this section, here\x27s a comparison routine for byte slices that uses two switch statements: \/\/ Compare returns an integer comparing the two byte slices, \/\/ lexicographically. \/\/ The result will be 0 if a == b, -1 if a \x3c b, and \x2b1 if a \x3e b func Compare(a, b []byte) int { for i := 0; i \x3c len(a) \x26\x26 i \x3c len(b); i\x2b\x2b { switch { case a[i] \x3e b[i]: return 1 case a[i] \x3c b[i]: return -1 } } switch { case len(a) \x3e len(b): return 1 case len(a) \x3c len(b): return -1 } return 0 } Type switch A switch can also be used to discover the dynamic type of an interface variable. Such a type switch uses the syntax of a type assertion with the keyword type inside the parentheses. If the switch declares a variable in the expression, the variable will have the corresponding type in each clause. It\x27s also idiomatic to reuse the name in such cases, in effect declaring a new variable with the same name but a different type in each case. var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(\x22unexpected type %T\x22, t) \/\/ %T prints whatever type t has case bool: fmt.Printf(\x22boolean %t\\n\x22, t) \/\/ t has type bool case int: fmt.Printf(\x22integer %d\\n\x22, t) \/\/ t has type int case *bool: fmt.Printf(\x22pointer to boolean %t\\n\x22, *t) \/\/ t has type *bool case *int: fmt.Printf(\x22pointer to integer %d\\n\x22, *t) \/\/ t has type *int } Functions Multiple return values One of Go\x27s unusual features is that functions and methods can return multiple values. This form can be used to improve on a couple of clumsy idioms in C programs: in-band error returns such as -1 for EOF and modifying an argument passed by address. In C, a write error is signaled by a negative count with the error code secreted away in a volatile location. In Go, Write can return a count and an error: “Yes, you wrote some bytes but not all of them because you filled the device”. The signature of the Write method on files from package os is: func (file *File) Write(b []byte) (n int, err error) and as the documentation says, it returns the number of bytes written and a non-nil error when n != len(b). This is a common style; see the section on error handling for more examples. A similar approach obviates the need to pass a pointer to a return value to simulate a reference parameter. Here\x27s a simple-minded function to grab a number from a position in a byte slice, returning the number and the next position. func nextInt(b []byte, i int) (int, int) { for ; i \x3c len(b) \x26\x26 !isDigit(b[i]); i\x2b\x2b { } x := 0 for ; i \x3c len(b) \x26\x26 isDigit(b[i]); i\x2b\x2b { x = x*10 \x2b int(b[i]) - \x270\x27 } return x, i } You could use it to scan the numbers in an input slice b like this: for i := 0; i \x3c len(b); { x, i = nextInt(b, i) fmt.Println(x) } Named result parameters The return or result \x22parameters\x22 of a Go function can be given names and used as regular variables, just like the incoming parameters. When named, they are initialized to the zero values for their types when the function begins; if the function executes a return statement with no arguments, the current values of the result parameters are used as the returned values. The names are not mandatory but they can make code shorter and clearer: they\x27re documentation. If we name the results of nextInt it becomes obvious which returned intis which. func nextInt(b []byte, pos int) (value, nextPos int) { Because named results are initialized and tied to an unadorned return, they can simplify as well as clarify. Here\x27s a version of io.ReadFull that uses them well: func ReadFull(r Reader, buf []byte) (n int, err error) { for len(buf) \x3e 0 \x26\x26 err == nil { var nr int nr, err = r.Read(buf) n \x2b= nr buf = buf[nr:] } return } Defer Go\x27s defer statement schedules a function call (the deferred function) to be run immediately before the function executing the defer returns. It\x27s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return. The canonical examples are unlocking a mutex or closing a file. \/\/ Contents returns the file\x27s contents as a string. func Contents(filename string) (string, error) { f, err := os.Open(filename) if err != nil { return \x22\x22, err } defer f.Close() \/\/ f.Close will run when we\x27re finished. var result []byte buf := make([]byte, 100) for { n, err := f.Read(buf[0:]) result = append(result, buf[0:n]...) \/\/ append is discussed later. if err != nil { if err == io.EOF { break } return \x22\x22, err \/\/ f will be closed if we return here. } } return string(result), nil \/\/ f will be closed if we return here. } Deferring a call to a function such as Close has two advantages. First, it guarantees that you will never forget to close the file, a mistake that\x27s easy to make if you later edit the function to add a new return path. Second, it means that the close sits near the open, which is much clearer than placing it at the end of the function. The arguments to the deferred function (which include the receiver if the function is a method) are evaluated when the defer executes, not when the call executes. Besides avoiding worries about variables changing values as the function executes, this means that a single deferred call site can defer multiple function executions. Here\x27s a silly example. for i := 0; i \x3c 5; i\x2b\x2b { defer fmt.Printf(\x22%d \x22, i) } Deferred functions are executed in LIFO order, so this code will cause 4 3 2 1 0 to be printed when the function returns. A more plausible example is a simple way to trace function execution through the program. We could write a couple of simple tracing routines like this: func trace(s string) { fmt.Println(\x22entering:\x22, s) } func untrace(s string) { fmt.Println(\x22leaving:\x22, s) } \/\/ Use them like this: func a() { trace(\x22a\x22) defer untrace(\x22a\x22) \/\/ do something.... } We can do better by exploiting the fact that arguments to deferred functions are evaluated when the defer executes. The tracing routine can set up the argument to the untracing routine. This example: func trace(s string) string { fmt.Println(\x22entering:\x22, s) return s } func un(s string) { fmt.Println(\x22leaving:\x22, s) } func a() { defer un(trace(\x22a\x22)) fmt.Println(\x22in a\x22) } func b() { defer un(trace(\x22b\x22)) fmt.Println(\x22in b\x22) a() } func main() { b() } prints entering: b in b entering: a in a leaving: a leaving: b For programmers accustomed to block-level resource management from other languages, defer may seem peculiar, but its most interesting and powerful applications come precisely from the fact that it\x27s not block-based but function-based. In the section on panic and recover we\x27ll see another example of its possibilities. Data Allocation with new Go has two allocation primitives, the built-in functions new and make. They do different things and apply to different types, which can be confusing, but the rules are simple. Let\x27s talk about new first. It\x27s a built-in function that allocates memory, but unlike its namesakes in some other languages it does not initialize the memory, it only zeros it. That is, new(T) allocates zeroed storage for a new item of type T and returns its address, a value of type *T. In Go terminology, it returns a pointer to a newly allocated zero value of type T. Since the memory returned by new is zeroed, it\x27s helpful to arrange when designing your data structures that the zero value of each type can be used without further initialization. This means a user of the data structure can create one with new and get right to work. For example, the documentation for bytes.Buffer states that \x22the zero value for Buffer is an empty buffer ready to use.\x22 Similarly, sync.Mutex does not have an explicit constructor or Init method. Instead, the zero value for a sync.Mutex is defined to be an unlocked mutex. The zero-value-is-useful property works transitively. Consider this type declaration. type SyncedBuffer struct { lock sync.Mutex buffer bytes.Buffer } Values of type SyncedBuffer are also ready to use immediately upon allocation or just declaration. In the next snippet, both p and v will work correctly without further arrangement. p := new(SyncedBuffer) \/\/ type *SyncedBuffer var v SyncedBuffer \/\/ type SyncedBuffer Constructors and composite literals Sometimes the zero value isn\x27t good enough and an initializing constructor is necessary, as in this example derived from package os. func NewFile(fd int, name string) *File { if fd \x3c 0 { return nil } f := new(File) f.fd = fd f.name = name f.dirinfo = nil f.nepipe = 0 return f } There\x27s a lot of boiler plate in there. We can simplify it using a composite literal, which is an expression that creates a new instance each time it is evaluated. func NewFile(fd int, name string) *File { if fd \x3c 0 { return nil } f := File{fd, name, nil, 0} return \x26f } Note that, unlike in C, it\x27s perfectly OK to return the address of a local variable; the storage associated with the variable survives after the function returns. In fact, taking the address of a composite literal allocates a fresh instance each time it is evaluated, so we can combine these last two lines. return \x26File{fd, name, nil, 0} The fields of a composite literal are laid out in order and must all be present. However, by labeling the elements explicitly as field:value pairs, the initializers can appear in any order, with the missing ones left as their respective zero values. Thus we could say return \x26File{fd: fd, name: name} As a limiting case, if a composite literal contains no fields at all, it creates a zero value for the type. The expressions new(File) and \x26File{} are equivalent. Composite literals can also be created for arrays, slices, and maps, with the field labels being indices or map keys as appropriate. In these examples, the initializations work regardless of the values of Enone, Eio, and Einval, as long as they are distinct. a := [...]string {Enone: \x22no error\x22, Eio: \x22Eio\x22, Einval: \x22invalid argument\x22} s := []string {Enone: \x22no error\x22, Eio: \x22Eio\x22, Einval: \x22invalid argument\x22} m := map[int]string{Enone: \x22no error\x22, Eio: \x22Eio\x22, Einval: \x22invalid argument\x22} Allocation with make Back to allocation. The built-in function make(T, args) serves a purpose different from new(T). It creates slices, maps, and channels only, and it returns an initialized (notzeroed) value of type T (not *T). The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. A slice, for example, is a three-item descriptor containing a pointer to the data (inside an array), the length, and the capacity, and until those items are initialized, the slice is nil. For slices, maps, and channels, make initializes the internal data structure and prepares the value for use. For instance, make([]int, 10, 100) allocates an array of 100 ints and then creates a slice structure with length 10 and a capacity of 100 pointing at the first 10 elements of the array. (When making a slice, the capacity can be omitted; see the section on slices for more information.) In contrast, new([]int) returns a pointer to a newly allocated, zeroed slice structure, that is, a pointer to a nil slice value. These examples illustrate the difference between new and make. var p *[]int = new([]int) \/\/ allocates slice structure; *p == nil; rarely useful var v []int = make([]int, 100) \/\/ the slice v now refers to a new array of 100 ints \/\/ Unnecessarily complex: var p *[]int = new([]int) *p = make([]int, 100, 100) \/\/ Idiomatic: v := make([]int, 100) Remember that make applies only to maps, slices and channels and does not return a pointer. To obtain an explicit pointer allocate with new or take the address of a variable explicitly. Arrays Arrays are useful when planning the detailed layout of memory and sometimes can help avoid allocation, but primarily they are a building block for slices, the subject of the next section. To lay the foundation for that topic, here are a few words about arrays. There are major differences between the ways arrays work in Go and C. In Go, Arrays are values. Assigning one array to another copies all the elements.In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it.The size of an array is part of its type. The types [10]int and [20]int are distinct. The value property can be useful but also expensive; if you want C-like behavior and efficiency, you can pass a pointer to the array. func Sum(a *[3]float64) (sum float64) { for _, v := range *a { sum \x2b= v } return } array := [...]float64{7.0, 8.5, 9.1} x := Sum(\x26array) \/\/ Note the explicit address-of operator But even this style isn\x27t idiomatic Go. Use slices instead. Slices Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays. Slices hold references to an underlying array, and if you assign one slice to another, both refer to the same array. If a function takes a slice argument, changes it makes to the elements of the slice will be visible to the caller, analogous to passing a pointer to the underlying array. A Read function can therefore accept a slice argument rather than a pointer and a count; the length within the slice sets an upper limit of how much data to read. Here is the signature of the Read method of the File type in package os: func (file *File) Read(buf []byte) (n int, err error) The method returns the number of bytes read and an error value, if any. To read into the first 32 bytes of a larger buffer buf, slice (here used as a verb) the buffer. n, err := f.Read(buf[0:32]) Such slicing is common and efficient. In fact, leaving efficiency aside for the moment, the following snippet would also read the first 32 bytes of the buffer. var n int var err error for i := 0; i \x3c 32; i\x2b\x2b { nbytes, e := f.Read(buf[i:i\x2b1]) \/\/ Read one byte. if nbytes == 0 || e != nil { err = e break } n \x2b= nbytes } The length of a slice may be changed as long as it still fits within the limits of the underlying array; just assign it to a slice of itself. The capacity of a slice, accessible by the built-in function cap, reports the maximum length the slice may assume. Here is a function to append data to a slice. If the data exceeds the capacity, the slice is reallocated. The resulting slice is returned. The function uses the fact that len and cap are legal when applied to the nil slice, and return 0. func Append(slice, data[]byte) []byte { l := len(slice) if l \x2b len(data) \x3e cap(slice) { \/\/ reallocate \/\/ Allocate double what\x27s needed, for future growth. newSlice := make([]byte, (l\x2blen(data))*2) \/\/ The copy function is predeclared and works for any slice type. copy(newSlice, slice) slice = newSlice } slice = slice[0:l\x2blen(data)] for i, c := range data { slice[l\x2bi] = c } return slice } We must return the slice afterwards because, although Append can modify the elements of slice, the slice itself (the run-time data structure holding the pointer, length, and capacity) is passed by value. The idea of appending to a slice is so useful it\x27s captured by the append built-in function. To understand that function\x27s design, though, we need a little more information, so we\x27ll return to it later. Two-dimensional slices Go\x27s arrays and slices are one-dimensional. To create the equivalent of a 2D array or slice, it is necessary to define an array-of-arrays or slice-of-slices, like this: type Transform [3][3]float64 \/\/ A 3x3 array, really an array of arrays. type LinesOfText [][]byte \/\/ A slice of byte slices. Because slices are variable-length, it is possible to have each inner slice be a different length. That can be a common situation, as in our LinesOfText example: each line has an independent length. text := LinesOfText{ []byte(\x22Now is the time\x22), []byte(\x22for all good gophers\x22), []byte(\x22to bring some fun to the party.\x22), } Sometimes it\x27s necessary to allocate a 2D slice, a situation that can arise when processing scan lines of pixels, for instance. There are two ways to achieve this. One is to allocate each slice independently; the other is to allocate a single array and point the individual slices into it. Which to use depends on your application. If the slices might grow or shrink, they should be allocated independently to avoid overwriting the next line; if not, it can be more efficient to construct the object with a single allocation. For reference, here are sketches of the two methods. First, a line at a time: \/\/ Allocate the top-level slice. picture := make([][]uint8, YSize) \/\/ One row per unit of y. \/\/ Loop over the rows, allocating the slice for each row. for i := range picture { picture[i] = make([]uint8, XSize) } And now as one allocation, sliced into lines: \/\/ Allocate the top-level slice, the same as before. picture := make([][]uint8, YSize) \/\/ One row per unit of y. \/\/ Allocate one large slice to hold all the pixels. pixels := make([]uint8, XSize*YSize) \/\/ Has type []uint8 even though picture is [][]uint8. \/\/ Loop over the rows, slicing each row from the front of the remaining pixels slice. for i := range picture { picture[i], pixels = pixels[:XSize], pixels[XSize:] } Maps Maps are a convenient and powerful built-in data structure that associate values of one type (the key) with values of another type (the element or value) The key can be of any type for which the equality operator is defined, such as integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays. Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller. Maps can be constructed using the usual composite literal syntax with colon-separated key-value pairs, so it\x27s easy to build them during initialization. var timeZone = map[string]int{ \x22UTC\x22: 0*60*60, \x22EST\x22: -5*60*60, \x22CST\x22: -6*60*60, \x22MST\x22: -7*60*60, \x22PST\x22: -8*60*60, } Assigning and fetching map values looks syntactically just like doing the same for arrays and slices except that the index doesn\x27t need to be an integer. offset := timeZone[\x22EST\x22] An attempt to fetch a map value with a key that is not present in the map will return the zero value for the type of the entries in the map. For instance, if the map contains integers, looking up a non-existent key will return 0. A set can be implemented as a map with value type bool. Set the map entry to true to put the value in the set, and then test it by simple indexing. attended := map[string]bool{ \x22Ann\x22: true, \x22Joe\x22: true, ... } if attended[person] { \/\/ will be false if person is not in the map fmt.Println(person, \x22was at the meeting\x22) } Sometimes you need to distinguish a missing entry from a zero value. Is there an entry for \x22UTC\x22 or is that the empty string because it\x27s not in the map at all? You can discriminate with a form of multiple assignment. var seconds int var ok bool seconds, ok = timeZone[tz] For obvious reasons this is called the “comma ok” idiom. In this example, if tz is present, seconds will be set appropriately and ok will be true; if not, seconds will be set to zero and ok will be false. Here\x27s a function that puts it together with a nice error report: func offset(tz string) int { if seconds, ok := timeZone[tz]; ok { return seconds } log.Println(\x22unknown time zone:\x22, tz) return 0 } To test for presence in the map without worrying about the actual value, you can use the blank identifier (_) in place of the usual variable for the value. _, present := timeZone[tz] To delete a map entry, use the delete built-in function, whose arguments are the map and the key to be deleted. It\x27s safe to do this even if the key is already absent from the map. delete(timeZone, \x22PDT\x22) \/\/ Now on Standard Time Printing Formatted printing in Go uses a style similar to C\x27s printf family but is richer and more general. The functions live in the fmt package and have capitalized names:fmt.Printf, fmt.Fprintf, fmt.Sprintf and so on. The string functions (Sprintf etc.) return a string rather than filling in a provided buffer. You don\x27t need to provide a format string. For each of Printf, Fprintf and Sprintf there is another pair of functions, for instance Print and Println. These functions do not take a format string but instead generate a default format for each argument. The Println versions also insert a blank between arguments and append a newline to the output while the Print versions add blanks only if the operand on neither side is a string. In this example each line produces the same output. fmt.Printf(\x22Hello %d\\n\x22, 23) fmt.Fprint(os.Stdout, \x22Hello \x22, 23, \x22\\n\x22) fmt.Println(\x22Hello\x22, 23) fmt.Println(fmt.Sprint(\x22Hello \x22, 23)) The formatted print functions fmt.Fprint and friends take as a first argument any object that implements the io.Writer interface; the variables os.Stdout and os.Stderr are familiar instances. Here things start to diverge from C. First, the numeric formats such as %d do not take flags for signedness or size; instead, the printing routines use the type of the argument to decide these properties. var x uint64 = 1\x3c\x3c64 - 1 fmt.Printf(\x22%d %x; %d %x\\n\x22, x, x, int64(x), int64(x)) prints 18446744073709551615 ffffffffffffffff; -1 -1 If you just want the default conversion, such as decimal for integers, you can use the catchall format %v (for “value”); the result is exactly what Print and Println would produce. Moreover, that format can print any value, even arrays, slices, structs, and maps. Here is a print statement for the time zone map defined in the previous section. fmt.Printf(\x22%v\\n\x22, timeZone) \/\/ or just fmt.Println(timeZone) which gives output map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200] For maps the keys may be output in any order, of course. When printing a struct, the modified format %\x2bv annotates the fields of the structure with their names, and for any value the alternate format %#v prints the value in full Go syntax. type T struct { a int b float64 c string } t := \x26T{ 7, -2.35, \x22abc\\tdef\x22 } fmt.Printf(\x22%v\\n\x22, t) fmt.Printf(\x22%\x2bv\\n\x22, t) fmt.Printf(\x22%#v\\n\x22, t) fmt.Printf(\x22%#v\\n\x22, timeZone) prints \x26{7 -2.35 abc def} \x26{a:7 b:-2.35 c:abc def} \x26main.T{a:7, b:-2.35, c:\x22abc\\tdef\x22} map[string] int{\x22CST\x22:-21600, \x22PST\x22:-28800, \x22EST\x22:-18000, \x22UTC\x22:0, \x22MST\x22:-25200} (Note the ampersands.) That quoted string format is also available through %q when applied to a value of type string or []byte. The alternate format %#q will use backquotes instead if possible. (The %q format also applies to integers and runes, producing a single-quoted rune constant.) Also, %x works on strings, byte arrays and byte slices as well as on integers, generating a long hexadecimal string, and with a space in the format (% x) it puts spaces between the bytes. Another handy format is %T, which prints the type of a value. fmt.Printf(\x22%T\\n\x22, timeZone) prints map[string] int If you want to control the default format for a custom type, all that\x27s required is to define a method with the signature String() string on the type. For our simple type T, that might look like this. func (t *T) String() string { return fmt.Sprintf(\x22%d\/%g\/%q\x22, t.a, t.b, t.c) } fmt.Printf(\x22%v\\n\x22, t) to print in the format 7\/-2.35\/\x22abc\\tdef\x22 (If you need to print values of type T as well as pointers to T, the receiver for String must be of value type; this example used a pointer because that\x27s more efficient and idiomatic for struct types. See the section below on pointers vs. value receivers for more information.) Our String method is able to call Sprintf because the print routines are fully reentrant and can be wrapped this way. There is one important detail to understand about this approach, however: don\x27t construct a String method by calling Sprintf in a way that will recur into your String method indefinitely. This can happen if the Sprintf call attempts to print the receiver directly as a string, which in turn will invoke the method again. It\x27s a common and easy mistake to make, as this example shows. type MyString string func (m MyString) String() string { return fmt.Sprintf(\x22MyString=%s\x22, m) \/\/ Error: will recur forever. } It\x27s also easy to fix: convert the argument to the basic string type, which does not have the method. type MyString string func (m MyString) String() string { return fmt.Sprintf(\x22MyString=%s\x22, string(m)) \/\/ OK: note conversion. } In the initialization section we\x27ll see another technique that avoids this recursion. Another printing technique is to pass a print routine\x27s arguments directly to another such routine. The signature of Printf uses the type ...interface{} for its final argument to specify that an arbitrary number of parameters (of arbitrary type) can appear after the format. func Printf(format string, v ...interface{}) (n int, err error) { Within the function Printf, v acts like a variable of type []interface{} but if it is passed to another variadic function, it acts like a regular list of arguments. Here is the implementation of the function log.Println we used above. It passes its arguments directly to fmt.Sprintln for the actual formatting. \/\/ Println prints to the standard logger in the manner of fmt.Println. func Println(v ...interface{}) { std.Output(2, fmt.Sprintln(v...)) \/\/ Output takes parameters (int, string) } We write ... after v in the nested call to Sprintln to tell the compiler to treat v as a list of arguments; otherwise it would just pass v as a single slice argument. There\x27s even more to printing than we\x27ve covered here. See the godoc documentation for package fmt for the details. By the way, a ... parameter can be of a specific type, for instance ...int for a min function that chooses the least of a list of integers: func Min(a ...int) int { min := int(^uint(0) \x3e\x3e 1) \/\/ largest int for _, i := range a { if i \x3c min { min = i } } return min } Append Now we have the missing piece we needed to explain the design of the append built-in function. The signature of append is different from our custom Append function above. Schematically, it\x27s like this: func append(slice []T, elements ...T) []T where T is a placeholder for any given type. You can\x27t actually write a function in Go where the type T is determined by the caller. That\x27s why append is built in: it needs support from the compiler. What append does is append the elements to the end of the slice and return the result. The result needs to be returned because, as with our hand-written Append, the underlying array may change. This simple example x := []int{1,2,3} x = append(x, 4, 5, 6) fmt.Println(x) prints [1 2 3 4 5 6]. So append works a little like Printf, collecting an arbitrary number of arguments. But what if we wanted to do what our Append does and append a slice to a slice? Easy: use ... at the call site, just as we did in the call to Output above. This snippet produces identical output to the one above. x := []int{1,2,3} y := []int{4,5,6} x = append(x, y...) fmt.Println(x) Without that ..., it wouldn\x27t compile because the types would be wrong; y is not of type int. Initialization Although it doesn\x27t look superficially very different from initialization in C or C\x2b\x2b, initialization in Go is more powerful. Complex structures can be built during initialization and the ordering issues among initialized objects, even among different packages, are handled correctly. Constants Constants in Go are just that—constant. They are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans. Because of the compile-time restriction, the expressions that define them must be constant expressions, evaluatable by the compiler. For instance, 1\x3c\x3c3 is a constant expression, while math.Sin(math.Pi\/4) is not because the function call to math.Sin needs to happen at run time. In Go, enumerated constants are created using the iota enumerator. Since iota can be part of an expression and expressions can be implicitly repeated, it is easy to build intricate sets of values. type ByteSize float64 const ( _ = iota \/\/ ignore first value by assigning to blank identifier KB ByteSize = 1 \x3c\x3c (10 * iota) MB GB TB PB EB ZB YB ) The ability to attach a method such as String to any user-defined type makes it possible for arbitrary values to format themselves automatically for printing. Although you\x27ll see it most often applied to structs, this technique is also useful for scalar types such as floating-point types like ByteSize. func (b ByteSize) String() string { switch { case b \x3e= YB: return fmt.Sprintf(\x22%.2fYB\x22, b\/YB) case b \x3e= ZB: return fmt.Sprintf(\x22%.2fZB\x22, b\/ZB) case b \x3e= EB: return fmt.Sprintf(\x22%.2fEB\x22, b\/EB) case b \x3e= PB: return fmt.Sprintf(\x22%.2fPB\x22, b\/PB) case b \x3e= TB: return fmt.Sprintf(\x22%.2fTB\x22, b\/TB) case b \x3e= GB: return fmt.Sprintf(\x22%.2fGB\x22, b\/GB) case b \x3e= MB: return fmt.Sprintf(\x22%.2fMB\x22, b\/MB) case b \x3e= KB: return fmt.Sprintf(\x22%.2fKB\x22, b\/KB) } return fmt.Sprintf(\x22%.2fB\x22, b) } The expression YB prints as 1.00YB, while ByteSize(1e13) prints as 9.09TB. The use here of Sprintf to implement ByteSize\x27s String method is safe (avoids recurring indefinitely) not because of a conversion but because it calls Sprintf with %f, which is not a string format: Sprintf will only call the String method when it wants a string, and %f wants a floating-point value. Variables Variables can be initialized just like constants but the initializer can be a general expression computed at run time. var ( home = os.Getenv(\x22HOME\x22) user = os.Getenv(\x22USER\x22) gopath = os.Getenv(\x22GOPATH\x22) ) The init function Finally, each source file can define its own niladic init function to set up whatever state is required. (Actually each file can have multiple init functions.) And finally means finally: init is called after all the variable declarations in the package have evaluated their initializers, and those are evaluated only after all the imported packages have been initialized. Besides initializations that cannot be expressed as declarations, a common use of init functions is to verify or repair correctness of the program state before real execution begins. func init() { if user == \x22\x22 { log.Fatal(\x22$USER not set\x22) } if home == \x22\x22 { home = \x22\/home\/\x22 \x2b user } if gopath == \x22\x22 { gopath = home \x2b \x22\/go\x22 } \/\/ gopath may be overridden by --gopath flag on command line. flag.StringVar(\x26gopath, \x22gopath\x22, gopath, \x22override default GOPATH\x22) } Methods Pointers vs. Values As we saw with ByteSize, methods can be defined for any named type (except a pointer or an interface); the receiver does not have to be a struct. In the discussion of slices above, we wrote an Append function. We can define it as a method on slices instead. To do this, we first declare a named type to which we can bind the method, and then make the receiver for the method a value of that type. type ByteSlice []byte func (slice ByteSlice) Append(data []byte) []byte { \/\/ Body exactly the same as above } This still requires the method to return the updated slice. We can eliminate that clumsiness by redefining the method to take a pointer to a ByteSlice as its receiver, so the method can overwrite the caller\x27s slice. func (p *ByteSlice) Append(data []byte) { slice := *p \/\/ Body as above, without the return. *p = slice } In fact, we can do even better. If we modify our function so it looks like a standard Write method, like this, func (p *ByteSlice) Write(data []byte) (n int, err error) { slice := *p \/\/ Again as above. *p = slice return len(data), nil } then the type *ByteSlice satisfies the standard interface io.Writer, which is handy. For instance, we can print into one. var b ByteSlice fmt.Fprintf(\x26b, \x22This hour has %d days\\n\x22, 7) We pass the address of a ByteSlice because only *ByteSlice satisfies io.Writer. The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers. This rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable b is addressable, so we can call itsWrite method with just b.Write. The compiler will rewrite that to (\x26b).Write for us. By the way, the idea of using Write on a slice of bytes is central to the implementation of bytes.Buffer. Interfaces and other types Interfaces Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here. We\x27ve seen a couple of simple examples already; custom printers can be implemented by a String method while Fprintf can generate output to anything with a Write method. Interfaces with only one or two methods are common in Go code, and are usually given a name derived from the method, such as io.Writer for something that implements Write. A type can implement multiple interfaces. For instance, a collection can be sorted by the routines in package sort if it implements sort.Interface, which contains Len(),Less(i, j int) bool, and Swap(i, j int), and it could also have a custom formatter. In this contrived example Sequence satisfies both. type Sequence []int \/\/ Methods required by sort.Interface. func (s Sequence) Len() int { return len(s) } func (s Sequence) Less(i, j int) bool { return s[i] \x3c s[j] } func (s Sequence) Swap(i, j int) { s[i], s[j] = s[j], s[i] } \/\/ Method for printing - sorts the elements before printing. func (s Sequence) String() string { sort.Sort(s) str := \x22[\x22 for i, elem := range s { if i \x3e 0 { str \x2b= \x22 \x22 } str \x2b= fmt.Sprint(elem) } return str \x2b \x22]\x22 } Conversions The String method of Sequence is recreating the work that Sprint already does for slices. We can share the effort if we convert the Sequence to a plain []int before callingSprint. func (s Sequence) String() string { sort.Sort(s) return fmt.Sprint([]int(s)) } This method is another example of the conversion technique for calling Sprintf safely from a String method. Because the two types (Sequence and []int) are the same if we ignore the type name, it\x27s legal to convert between them. The conversion doesn\x27t create a new value, it just temporarily acts as though the existing value has a new type. (There are other legal conversions, such as from integer to floating point, that do create a new value.) It\x27s an idiom in Go programs to convert the type of an expression to access a different set of methods. As an example, we could use the existing type sort.IntSlice to reduce the entire example to this: type Sequence []int \/\/ Method for printing - sorts the elements before printing func (s Sequence) String() string { sort.IntSlice(s).Sort() return fmt.Sprint([]int(s)) } Now, instead of having Sequence implement multiple interfaces (sorting and printing), we\x27re using the ability of a data item to be converted to multiple types (Sequence,sort.IntSlice and []int), each of which does some part of the job. That\x27s more unusual in practice but can be effective. Interface conversions and type assertions Type switches are a form of conversion: they take an interface and, for each case in the switch, in a sense convert it to the type of that case. Here\x27s a simplified version of how the code under fmt.Printf turns a value into a string using a type switch. If it\x27s already a string, we want the actual string value held by the interface, while if it has aString method we want the result of calling the method. type Stringer interface { String() string } var value interface{} \/\/ Value provided by caller. switch str := value.(type) { case string: return str case Stringer: return str.String() } The first case finds a concrete value; the second converts the interface into another interface. It\x27s perfectly fine to mix types this way. What if there\x27s only one type we care about? If we know the value holds a string and we just want to extract it? A one-case type switch would do, but so would a type assertion. A type assertion takes an interface value and extracts from it a value of the specified explicit type. The syntax borrows from the clause opening a type switch, but with an explicit type rather than the type keyword: value.(typeName) and the result is a new value with the static type typeName. That type must either be the concrete type held by the interface, or a second interface type that the value can be converted to. To extract the string we know is in the value, we could write: str := value.(string) But if it turns out that the value does not contain a string, the program will crash with a run-time error. To guard against that, use the \x22comma, ok\x22 idiom to test, safely, whether the value is a string: str, ok := value.(string) if ok { fmt.Printf(\x22string value is: %q\\n\x22, str) } else { fmt.Printf(\x22value is not a string\\n\x22) } If the type assertion fails, str will still exist and be of type string, but it will have the zero value, an empty string. As an illustration of the capability, here\x27s an if-else statement that\x27s equivalent to the type switch that opened this section. if str, ok := value.(string); ok { return str } else if str, ok := value.(Stringer); ok { return str.String() } Generality If a type exists only to implement an interface and has no exported methods beyond that interface, there is no need to export the type itself. Exporting just the interface makes it clear that it\x27s the behavior that matters, not the implementation, and that other implementations with different properties can mirror the behavior of the original type. It also avoids the need to repeat the documentation on every instance of a common method. In such cases, the constructor should return an interface value rather than the implementing type. As an example, in the hash libraries both crc32.NewIEEE and adler32.Newreturn the interface type hash.Hash32. Substituting the CRC-32 algorithm for Adler-32 in a Go program requires only changing the constructor call; the rest of the code is unaffected by the change of algorithm. A similar approach allows the streaming cipher algorithms in the various crypto packages to be separated from the block ciphers they chain together. The Block interface in the crypto\/cipher package specifies the behavior of a block cipher, which provides encryption of a single block of data. Then, by analogy with the bufio package, cipher packages that implement this interface can be used to construct streaming ciphers, represented by the Stream interface, without knowing the details of the block encryption. The crypto\/cipher interfaces look like this: type Block interface { BlockSize() int Encrypt(src, dst []byte) Decrypt(src, dst []byte) } type Stream interface { XORKeyStream(dst, src []byte) } Here\x27s the definition of the counter mode (CTR) stream, which turns a block cipher into a streaming cipher; notice that the block cipher\x27s details are abstracted away: \/\/ NewCTR returns a Stream that encrypts\/decrypts using the given Block in \/\/ counter mode. The length of iv must be the same as the Block\x27s block size. func NewCTR(block Block, iv []byte) Stream NewCTR applies not just to one specific encryption algorithm and data source but to any implementation of the Block interface and any Stream. Because they return interface values, replacing CTR encryption with other encryption modes is a localized change. The constructor calls must be edited, but because the surrounding code must treat the result only as a Stream, it won\x27t notice the difference. Interfaces and methods Since almost anything can have methods attached, almost anything can satisfy an interface. One illustrative example is in the http package, which defines the Handlerinterface. Any object that implements Handler can serve HTTP requests. type Handler interface { ServeHTTP(ResponseWriter, *Request) } ResponseWriter is itself an interface that provides access to the methods needed to return the response to the client. Those methods include the standard Write method, so an http.ResponseWriter can be used wherever an io.Writer can be used. Request is a struct containing a parsed representation of the request from the client. For brevity, let\x27s ignore POSTs and assume HTTP requests are always GETs; that simplification does not affect the way the handlers are set up. Here\x27s a trivial but complete implementation of a handler to count the number of times the page is visited. \/\/ Simple counter server. type Counter struct { n int } func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) { ctr.n\x2b\x2b fmt.Fprintf(w, \x22counter = %d\\n\x22, ctr.n) } (Keeping with our theme, note how Fprintf can print to an http.ResponseWriter.) For reference, here\x27s how to attach such a server to a node on the URL tree. import \x22net\/http\x22 ... ctr := new(Counter) http.Handle(\x22\/counter\x22, ctr) But why make Counter a struct? An integer is all that\x27s needed. (The receiver needs to be a pointer so the increment is visible to the caller.) \/\/ Simpler counter server. type Counter int func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) { *ctr\x2b\x2b fmt.Fprintf(w, \x22counter = %d\\n\x22, *ctr) } What if your program has some internal state that needs to be notified that a page has been visited? Tie a channel to the web page. \/\/ A channel that sends a notification on each visit. \/\/ (Probably want the channel to be buffered.) type Chan chan *http.Request func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) { ch \x3c- req fmt.Fprint(w, \x22notification sent\x22) } Finally, let\x27s say we wanted to present on \/args the arguments used when invoking the server binary. It\x27s easy to write a function to print the arguments. func ArgServer() { fmt.Println(os.Args) } How do we turn that into an HTTP server? We could make ArgServer a method of some type whose value we ignore, but there\x27s a cleaner way. Since we can define a method for any type except pointers and interfaces, we can write a method for a function. The http package contains this code: \/\/ The HandlerFunc type is an adapter to allow the use of \/\/ ordinary functions as HTTP handlers. If f is a function \/\/ with the appropriate signature, HandlerFunc(f) is a \/\/ Handler object that calls f. type HandlerFunc func(ResponseWriter, *Request) \/\/ ServeHTTP calls f(c, req). func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) { f(w, req) } HandlerFunc is a type with a method, ServeHTTP, so values of that type can serve HTTP requests. Look at the implementation of the method: the receiver is a function, f, and the method calls f. That may seem odd but it\x27s not that different from, say, the receiver being a channel and the method sending on the channel. To make ArgServer into an HTTP server, we first modify it to have the right signature. \/\/ Argument server. func ArgServer(w http.ResponseWriter, req *http.Request) { fmt.Fprintln(w, os.Args) } ArgServer now has same signature as HandlerFunc, so it can be converted to that type to access its methods, just as we converted Sequence to IntSlice to accessIntSlice.Sort. The code to set it up is concise: http.Handle(\x22\/args\x22, http.HandlerFunc(ArgServer)) When someone visits the page \/args, the handler installed at that page has value ArgServer and type HandlerFunc. The HTTP server will invoke the method ServeHTTP of that type, with ArgServer as the receiver, which will in turn call ArgServer (via the invocation f(c, req) inside HandlerFunc.ServeHTTP). The arguments will then be displayed. In this section we have made an HTTP server from a struct, an integer, a channel, and a function, all because interfaces are just sets of methods, which can be defined for (almost) any type. The blank identifier We\x27ve mentioned the blank identifier a couple of times now, in the context of for range loops and maps. The blank identifier can be assigned or declared with any value of any type, with the value discarded harmlessly. It\x27s a bit like writing to the Unix \/dev\/null file: it represents a write-only value to be used as a place-holder where a variable is needed but the actual value is irrelevant. It has uses beyond those we\x27ve seen already. The blank identifier in multiple assignment The use of a blank identifier in a for range loop is a special case of a general situation: multiple assignment. If an assignment requires multiple values on the left side, but one of the values will not be used by the program, a blank identifier on the left-hand-side of the assignment avoids the need to create a dummy variable and makes it clear that the value is to be discarded. For instance, when calling a function that returns a value and an error, but only the error is important, use the blank identifier to discard the irrelevant value. if _, err := os.Stat(path); os.IsNotExist(err) { fmt.Printf(\x22%s does not exist\\n\x22, path) } Occasionally you\x27ll see code that discards the error value in order to ignore '.length;
	var readTime = Math.round(len / 900);
	if (readTime >= 1) {
		$('.read-time').text('预计阅读时间 '+readTime+' 分钟');
	} else {
		$('.read-time').text('预计阅读时间不到 1 分钟');
	}
});
</script>

<script type="text/javascript" src="./Effective Go - Go语言中文网 - Golang中文社区_files/ckeditor.js.下载"></script>
<script type="text/javascript" src="./Effective Go - Go语言中文网 - Golang中文社区_files/config.js.下载"></script>
<script type="text/javascript" src="./Effective Go - Go语言中文网 - Golang中文社区_files/article.js.下载"></script>


<script type="text/javascript">
$(function(){
	$('code[class*="language-"]').parent('pre').addClass('line-numbers');
});
</script>
<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/prism.min.js.下载"></script>
<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/prism-go.min.js.下载"></script>
<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/prism-json.min.js.下载"></script>
<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/prism-bash.min.js.下载"></script>
<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/prism-python.min.js.下载"></script>
<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/prism-nasm.min.js.下载"></script>
<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/prism-yaml.min.js.下载"></script>
<script src="./Effective Go - Go语言中文网 - Golang中文社区_files/prism-line-numbers.min.js.下载"></script>

<script type="text/javascript">
Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.text = Prism.languages.go;
Prism.languages.golang = Prism.languages.go;
Prism.languages.none = Prism.languages.go;
Prism.languages.console = Prism.languages.bash;
Prism.languages.shell = Prism.languages.bash;
Prism.languages.asm = Prism.languages.nasm;
Prism.languages.makefile = Prism.languages.bash;
Prism.languages.Dockerfile = Prism.languages.bash;
Prism.languages.protobuf = Prism.languages.clike;
Prism.languages.c = Prism.languages.clike;
</script>


	



	




	<script type="text/javascript" src="./Effective Go - Go语言中文网 - Golang中文社区_files/sidebar.min.js.下载"></script>

	
		
		

<script async="" src="./Effective Go - Go语言中文网 - Golang中文社区_files/adsbygoogle.js.下载"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-4512014793067058",
    enable_page_level_ads: true
  });
</script><ins class="adsbygoogle adsbygoogle-noablate" data-adsbygoogle-status="done" style="display: none;"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:NaNpx;margin:0;padding:0;position:relative;visibility:visible;width:NaNpx;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:NaNpx;margin:0;padding:0;position:relative;visibility:visible;width:NaNpx;background-color:transparent;"><iframe frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:NaNpx;height:NaNpx;" src="./Effective Go - Go语言中文网 - Golang中文社区_files/saved_resource(10).html"></iframe></ins></ins></ins>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-18275235-2', 'auto');
  ga('send', 'pageview');

</script>


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?224c227cd9239761ec770bc8c1fb134c";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
<script>
(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  } else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();
</script>

	



</body></html>